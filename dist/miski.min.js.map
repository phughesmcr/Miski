{"version":3,"file":"miski.min.js","sources":["../src/constants.ts","../src/utils/utils.ts","../src/component/schema.ts","../src/component/component.ts","../src/query/query.ts","../src/system.ts","../src/bits/constants.ts","../src/bits/utils.ts","../src/bits/bitfield.ts","../src/archetype/archetype.ts","../src/archetype/manager.ts","../src/bits/bitpool.ts","../src/component/proxy.ts","../src/component/instance.ts","../src/component/sparse-facade.ts","../src/component/buffer.ts","../src/component/manager.ts","../src/query/manager.ts","../src/query/instance.ts","../src/world.ts"],"sourcesContent":["/* Copyright 2023 the Miski authors. All rights reserved. MIT license. */\n\n/** Miski version */\nexport const VERSION = \"__VERSION__\"; // __VERSION__ is replaced by rollup\n\n/** Maximum 32-bit integer (2^32 - 1) */\nexport const MAX_UINT32 = 4_294_967_295;\n\n/** An array of strings that cannot be used for component or schema property names */\nexport const FORBIDDEN_NAMES = Object.freeze(\n  new Set([\n    // component properties:\n    \"changed\",\n    \"component\",\n    \"count\",\n    \"eid\",\n    \"entity\",\n    \"id\",\n    \"isTag\",\n    \"maxEntities\",\n    \"name\",\n    \"owners\",\n    \"proxy\",\n    \"schema\",\n    \"size\",\n    // object properties:\n    \"constructor\",\n    \"hasOwnProperty\",\n    \"isPrototypeOf\",\n    \"propertyIsEnumerable\",\n    \"prototype\",\n    \"toLocaleString\",\n    \"toString\",\n    \"valueOf\",\n    \"__defineGetter__\",\n    \"__defineSetter__\",\n    \"__lookupGetter__\",\n    \"__lookupGetter__\",\n    \"__proto__\",\n  ]),\n);\n\n/** Valid string name characters */\nexport const VALID_NAME_PATTERN = /^(?![0-9])[a-zA-Z0-9$_]+$/;\n\n/** A frozen empty array to avoid multiple object creation at certain points */\nexport const EMPTY_ARRAY = Object.freeze([]);\n\n/** Symbol for use as a key for the `changed` flag getter and setter */\nexport const $_CHANGED = Symbol(\"changed\");\n\n/** Symbol for use as a key for the `owners` flag getter and setter */\nexport const $_OWNERS = Symbol(\"owners\");\n","/* Copyright 2023 the Miski authors. All rights reserved. MIT license. */\n\nimport { FORBIDDEN_NAMES, MAX_UINT32, VALID_NAME_PATTERN } from \"../constants.js\";\n\n/** @returns `true` if n is a number, >= 0, <= 2^32 - 1 */\nexport function isUint32(n: number): n is number {\n  return !isNaN(n) && n >= 0 && n <= MAX_UINT32;\n}\n\n/** @returns true if `n` is a Uint32 > 0 */\nexport function isPositiveInt(n: number) {\n  return isUint32(n) && n > 0;\n}\n\n/** All the various kinds of typed arrays */\nexport type TypedArray =\n  | Int8Array\n  | Uint8Array\n  | Uint8ClampedArray\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Float32Array\n  | Float64Array\n  | BigInt64Array\n  | BigUint64Array;\n\n/** All the various kinds of typed array constructors */\nexport type TypedArrayConstructor =\n  | Int8ArrayConstructor\n  | Uint8ArrayConstructor\n  | Uint8ClampedArrayConstructor\n  | Int16ArrayConstructor\n  | Uint16ArrayConstructor\n  | Int32ArrayConstructor\n  | Uint32ArrayConstructor\n  | Float32ArrayConstructor\n  | Float64ArrayConstructor\n  | BigInt64ArrayConstructor\n  | BigUint64ArrayConstructor;\n\n/** Test if an object is a typed array and not a dataview */\nexport function isTypedArray(object: unknown): object is TypedArray {\n  return Boolean(ArrayBuffer.isView(object) && !(object instanceof DataView));\n}\n\n/** Test if an object is a typed array constructor (e.g., `Uint8Array`) */\nexport function isTypedArrayConstructor(object: unknown): object is TypedArrayConstructor {\n  return Boolean(typeof object === \"function\" && Object.prototype.hasOwnProperty.call(object, \"BYTES_PER_ELEMENT\"));\n}\n\n/** @returns `true` if the given string is an valid name / label */\nexport function isValidName(str: string): boolean {\n  return Boolean(\n    typeof str === \"string\" && str.length > 0 && !FORBIDDEN_NAMES.has(str) && VALID_NAME_PATTERN.test(str),\n  );\n}\n\n/** Test if an object is a valid Record  */\nexport function isObject(object: unknown): object is Record<string, unknown> {\n  return Boolean(typeof object === \"object\" && !Array.isArray(object));\n}\n\n/**\n * The parameters of a function omitting the first two parameters\n * @author https://stackoverflow.com/a/67605309\n */\nexport type ParametersExceptFirstTwo<F> = F extends (arg0: any, arg1: any, ...rest: infer R) => any ? R : never;\n\n/**\n * Opaque typing allows for nominal types\n * @example\n * type Entity = number;\n * const a: Entity = 1; // a = number;\n * type Entity = Opaque<number, \"Entity\">;\n * const b: Entity = 1 // b = Entity;\n */\nexport type Opaque<T, K> = T & { _TYPE: K };\n\n/** Creates a function that will round a number up to a given multiple */\nexport function roundUpToMultipleOf(f: number): (n: number) => number {\n  return (n: number) => Math.ceil(n / f) * f;\n}\n\n/** @returns the input rounded up to the closest multiple of 4 */\nexport const multipleOf4 = roundUpToMultipleOf(4);\n\n/** @returns the input rounded up to the closest multiple of 8 */\nexport const multipleOf8 = roundUpToMultipleOf(8);\n","/* Copyright 2023 the Miski authors. All rights reserved. MIT license. */\n\nimport { isObject, isTypedArrayConstructor, isValidName } from \"../utils/utils.js\";\nimport type { TypedArray, TypedArrayConstructor } from \"../utils/utils.js\";\n\n/** Individual entity's component properties */\nexport type SchemaProps<T> = Record<keyof T, number | bigint | undefined>;\n\n/** Internal component data storage */\nexport type SchemaStorage<T> = Record<keyof T, TypedArray>;\n\n/**\n * Schemas are component storage definitions:\n *\n * Schemas use TypedArray objects and so can only store a single number per property per entity.\n *\n * For example, `{ property: Int8Array }`;\n *\n * Values in TypedArrays are initialised to 0 by default.\n *\n * To set an initial value: `{ property: [Int8Array, defaultValue] }`.\n *\n * Set to `null` to define a tag component.\n */\nexport type Schema<T> = null | Record<keyof T, TypedArrayConstructor | [TypedArrayConstructor, number]>;\n\n/** Validates the properties of a schema entry */\nfunction _validateProps(value: TypedArrayConstructor | [TypedArrayConstructor, number]): boolean {\n  if (Array.isArray(value)) {\n    // if this is an array, the user wants to set an initial value\n    const [TAC, n] = value;\n    return !isNaN(n) && isTypedArrayConstructor(TAC);\n  }\n  return isTypedArrayConstructor(value);\n}\n\n/** Validates the names and values of a schema's entries */\nfunction _validateSchemaEntry([name, value]: [string, unknown]): boolean {\n  return isValidName(name) && _validateProps(value as TypedArrayConstructor | [TypedArrayConstructor, number]);\n}\n\n/** Schema type guard */\nexport function isValidSchema<T extends Schema<T>>(schema: unknown): schema is Schema<T> {\n  try {\n    if (schema === undefined) return false;\n    if (schema === null) return true;\n    if (!isObject(schema)) return false;\n    const entries = Object.entries(schema);\n    if (!entries.length) return false;\n    return entries.every(_validateSchemaEntry);\n  } catch (_) {\n    return false;\n  }\n}\n\n/**\n * Utility function to add a typed array's bytes per element to a total\n * @see calculateSchemaSize\n */\nfunction byteSum(total: unknown, value: unknown): number {\n  const size = Array.isArray(value)\n    ? (value[0] as TypedArray).BYTES_PER_ELEMENT\n    : (value as TypedArray).BYTES_PER_ELEMENT;\n  return (total as number) + size;\n}\n\n/**\n * @returns the size in bytes that a component's storage requires for one entity\n *          or NaN if the object is invalid;\n */\nexport function calculateSchemaSize<T extends Schema<T>>(schema: Schema<T>): number {\n  try {\n    if (!isValidSchema(schema)) return Number.NaN;\n    if (schema === null) return 0;\n    /** @todo should this be to multipleOf4? */\n    return Object.values(schema).reduce(byteSum, 0) as number;\n  } catch (_) {\n    return Number.NaN;\n  }\n}\n","/* Copyright 2023 the Miski authors. All rights reserved. MIT license. */\n\nimport { isPositiveInt, isValidName } from \"../utils/utils.js\";\nimport { calculateSchemaSize, isValidSchema, Schema } from \"./schema.js\";\n\nexport interface ComponentSpec<T> {\n  /**\n   * The maximum number of entities able to equip this component per world.\n   *\n   * __Warning__: use this only where memory consumption is a concern, performance will be worse.\n   */\n  maxEntities?: number;\n  /** The component's label */\n  name: string;\n  /** The component's property definitions. Omit to define a tag component. */\n  schema?: Schema<T>;\n}\n\nexport class Component<T extends Schema<T>> {\n  /** `true` if the component has no schema */\n  readonly isTag: boolean;\n  /** The maximum number of entities able to equip this component per world. */\n  readonly maxEntities: number | null;\n  /** The component's label */\n  readonly name: string;\n  /** The component's property definitions or `null` if component is a tag */\n  readonly schema: Readonly<Schema<T>> | null;\n  /** The storage requirements of the schema in bytes for a single entity */\n  readonly size: number;\n\n  /**\n   * Define a new component.\n   * @param spec the component's specification.\n   * @param spec.name the component's string identifier.\n   * @param spec.schema the component's optional schema object.\n   * @returns A valid Component object - a reusable definitions for the creation of ComponentInstances\n   * @throws If the spec is invalid\n   */\n  constructor(spec: ComponentSpec<T>) {\n    if (!spec) throw new SyntaxError(\"A specification object is required.\");\n    const { maxEntities = null, name, schema = null } = spec;\n    if (maxEntities && !isPositiveInt(maxEntities)) throw new SyntaxError(\"spec.maxEntities must be a Uint32 > 0.\");\n    if (!isValidName(name)) throw new SyntaxError(\"spec.name is invalid.\");\n    if (!isValidSchema(schema)) throw new SyntaxError(\"spec.schema is invalid.\");\n    this.isTag = !schema;\n    this.maxEntities = maxEntities ?? null;\n    this.name = name;\n    this.schema = schema ? Object.freeze({ ...schema }) : null;\n    this.size = schema ? calculateSchemaSize(schema) : 0;\n    Object.freeze(this);\n  }\n}\n","/* Copyright 2023 the Miski authors. All rights reserved. MIT license. */\n\nimport { Component } from \"../component/component.js\";\nimport { EMPTY_ARRAY } from \"../constants.js\";\nimport type { Schema } from \"../component/schema.js\";\n\nexport interface QuerySpec {\n  /** AND - Gather entities as long as they have all these components */\n  all?: Component<any>[];\n  /** OR - Gather entities as long as they have 0...* of these components */\n  any?: Component<any>[];\n  /** NOT - Gather entities as long as they don't have these components */\n  none?: Component<any>[];\n}\n\nfunction _validateQueryArrays<T extends Schema<T>>(component: Component<T>) {\n  return component instanceof Component;\n}\n\nexport class Query {\n  /** AND - Gather entities as long as they have all these components */\n  readonly all: Readonly<Component<any>[]>;\n  /** OR - Gather entities as long as they have 0...* of these components */\n  readonly any: Readonly<Component<any>[]>;\n  /** NOT - Gather entities as long as they don't have these components */\n  readonly none: Readonly<Component<any>[]>;\n\n  /**\n   * Create a new Query\n   *\n   * Queries are groupings of archetypes\n   *\n   * @param spec The Query's specification object\n   * @param spec.all AND - Gather entities as long as they have all these components\n   * @param spec.any OR - Gather entities as long as they have 0...* of these components\n   * @param spec.none NOT - Gather entities as long as they don't have these components\n   * @throws If the spec is invalid\n   */\n  constructor(spec: QuerySpec) {\n    if (!spec) throw new SyntaxError(\"Query specification object is required.\");\n    const { all = EMPTY_ARRAY, any = EMPTY_ARRAY, none = EMPTY_ARRAY } = spec;\n    if (![...all, ...any, ...none].every(_validateQueryArrays)) {\n      throw new SyntaxError(\"Query specification object is invalid.\");\n    }\n    this.all = Object.freeze([...new Set(all)]);\n    this.any = Object.freeze([...new Set(any)]);\n    this.none = Object.freeze([...new Set(none)]);\n    Object.freeze(this);\n  }\n}\n","/* Copyright 2023 the Miski authors. All rights reserved. MIT license. */\n\nimport type { Query } from \"./query/query.js\";\nimport type { ComponentRecord } from \"./component/manager.js\";\nimport type { ParametersExceptFirstTwo } from \"./utils/utils.js\";\nimport type { Entity, World } from \"./world.js\";\n\n/**\n * A multi-arity function where the first two parameters\n * are the components and entities available to\n * the system respectively.\n */\nexport type SystemCallback<\n  T extends (components: ComponentRecord, entities: IterableIterator<Entity>, ...args: unknown[]) => ReturnType<T>,\n  U extends ParametersExceptFirstTwo<T>,\n> = (components: ComponentRecord, entities: IterableIterator<Entity>, ...args: U) => ReturnType<T>;\n\nexport interface SystemSpec<\n  T extends (components: ComponentRecord, entities: IterableIterator<Entity>, ...args: unknown[]) => ReturnType<T>,\n  U extends ParametersExceptFirstTwo<T>,\n> {\n  /** The core function of the system. Called when this.exec is called. */\n  system: SystemCallback<T, U>;\n  /** The query which will provide the components and entities to the system. */\n  query: Query;\n}\n\nexport class System<\n  T extends (components: ComponentRecord, entities: IterableIterator<Entity>, ...args: unknown[]) => ReturnType<T>,\n  U extends ParametersExceptFirstTwo<T>,\n> {\n  /** The core function of the system. Called when this.exec is called. */\n  system: SystemCallback<T, U>;\n  /** The query which will provide the components and entities to the system. */\n  query: Query;\n\n  /**\n   * Creates a new system.\n   *\n   * Systems are the behaviours which affect components.\n   *\n   * @param spec the system's specification object\n   */\n  constructor(spec: SystemSpec<T, U>) {\n    const { system, query } = spec;\n    this.system = system;\n    this.query = query;\n  }\n\n  /**\n   * Initialize the system for a given world\n   * @param world the world to execute the system in\n   * @returns an initialized system function\n   */\n  init(world: World): (...args: U) => ReturnType<T> {\n    const components = world.getQueryComponents(this.query);\n    const getEntities = world.getQueryEntities(this.query);\n    /**\n     * @param args arguments to pass to the system's callback function\n     * @returns the result of the system's callback function\n     */\n    return (...args: U) => this.system(components, getEntities(), ...args);\n  }\n}\n","/* Copyright 2023 the Miski authors. All rights reserved. MIT license. */\n\n/** The number of bits per integer value in the bitfield */\nexport const BITS_PER_INT = 32;\n\n/** Value representing an erroneous or non-existant index in the bitfield */\nexport const NO_INDEX = -1;\n\n/** Lookup table for powers of 2 */\nexport const LOG_2: Record<number, number> = Object.freeze({\n  1: 0,\n  2: 1,\n  4: 2,\n  8: 3,\n  16: 4,\n  32: 5,\n  64: 6,\n  128: 7,\n  256: 8,\n  512: 9,\n  1024: 10,\n  2048: 11,\n  4096: 12,\n  8192: 13,\n  16384: 14,\n  32768: 15,\n  65536: 16,\n  131072: 17,\n  262144: 18,\n  524288: 19,\n  1048576: 20,\n  2097152: 21,\n  4194304: 22,\n  8388608: 23,\n  16777216: 24,\n  33554432: 25,\n  67108864: 26,\n  134217728: 27,\n  268435456: 28,\n  536870912: 29,\n  1073741824: 30,\n  2147483648: 31,\n  [-2147483648]: 31,\n});\n","/* Copyright 2023 the Miski authors. All rights reserved. MIT license. */\n\nimport { LOG_2, NO_INDEX } from \"./constants.js\";\n\n/**\n * Count the number of set bits in a 32-bit integer (\"population count\").\n * @returns the number of set bits in a given value\n * @see https://graphics.stanford.edu/~seander/bithacks.html\n * @license public-domain\n */\nexport const getPopulationCount = (value: number): number => {\n  const a = value - ((value >> 1) & 0x55555555);\n  const b = (a & 0x33333333) + ((a >> 2) & 0x33333333);\n  return (((b + (b >> 4)) & 0xf0f0f0f) * 0x1010101) >> 24;\n};\n\nexport const getLowestSetBit = (value: number) => value & -value;\n\nexport const getLowestSetPosition = (value: number) => LOG_2[getLowestSetBit(value)] ?? NO_INDEX;\n\nexport const intersectBits = (a = 0, b = 0): number => a & b;\n","/* Copyright 2023 the Miski authors. All rights reserved. MIT license. */\n\nimport { BITS_PER_INT, NO_INDEX } from \"./constants.js\";\nimport { getPopulationCount as popcnt } from \"./utils.js\";\n\n/**\n *\n */\nexport type Bitfield = Uint32Array;\n\n/**\n * @returns The amount of bits in the array\n */\nexport const getSize = (field: Bitfield) => field.length << 5;\n\n/**\n * @returns the index of a bit in a bitfield, -1 if not found\n */\nexport const indexOf = (bit: number): number => {\n  if (isNaN(bit)) throw new TypeError(`Expected a number, found \"${typeof bit}\"`);\n  if (bit < 0) return NO_INDEX;\n  return bit >>> 5;\n};\n\n/**\n * Toggle a bit in the Bitfield\n * @return the resulting state of the bit\n */\nexport const toggle = (field: Bitfield, bit: number): boolean => {\n  const i = indexOf(bit);\n  if (i === NO_INDEX) throw new RangeError(`Bit ${bit} does not exist in the bitfield.`);\n  const value = 1 << (bit - i * BITS_PER_INT);\n  field[i] ^= value;\n  return !!(field[i]! & (1 << value));\n};\n\n/**\n * Creates a new Bitfield\n * @param size the number of bits in the array\n */\nexport const create = (size: number): Bitfield => {\n  return new Uint32Array(Math.ceil(size / BITS_PER_INT));\n};\n\n/**\n *\n * @returns a new Bitfield with identical properties to this Bitfield\n */\nexport const clone = (field: Bitfield): Bitfield => {\n  const size = getSize(field);\n  const result = create(size);\n  result.set(field);\n  return result;\n};\n\n/**\n * @returns a new Bitfield based on this one with toggled bits\n */\nexport const cloneWithToggle = <T>(field: Bitfield, key: keyof T, sources: T[]): Bitfield => {\n  const res = clone(field);\n  const visited: Set<number> = new Set();\n  for (const source of sources) {\n    const value = source[key] as number;\n    if (visited.has(value)) continue;\n    toggle(res, value);\n    visited.add(value);\n  }\n  return res;\n};\n\n/**\n * Create a new Bitfield from an array of objects\n * @param size the number of bits in the bitfield\n * @param key the key of the property to use for the bitfield's indexes\n * @param objs an array of objects which have the key as an index to a number\n *\n * @example\n *  // Creating 43 bit bitfield from <T extends { id: number }>:\n *  Bitfield.fromObjects(43, \"id\", [{ id: 0, ... }, ...]);\n */\nexport const fromObjects = <T>(size: number, key: keyof T, objs: T[]): Bitfield => {\n  const res = create(size);\n  const visited: Set<number> = new Set();\n  for (const obj of objs) {\n    const value = obj[key] as number;\n    if (visited.has(value)) continue;\n    toggle(res, value);\n    visited.add(value);\n  }\n  return res;\n};\n\n/**\n * @returns the number of set bits in a given bitfield\n */\nexport const getPopulationCount = (field: Bitfield): number =>\n  field.reduce((res, val) => {\n    if (!val) return res;\n    return res + popcnt(val);\n  }, 0);\n\n/**\n * @returns the index and position of a bit in the bitfield\n */\nexport const getPosition = (bit: number): { index: number; position: number } => ({\n  index: indexOf(bit),\n  position: bit & 31,\n});\n\n/**\n * @returns `true` if a given bit is set in the Bitfield\n */\nexport const isSet = (field: Bitfield, bit: number): boolean => {\n  const idx = indexOf(bit);\n  if (idx === NO_INDEX) throw new RangeError(`Bit ${bit} does not exist in the bitfield.`);\n  return !!(field[idx]! & (1 << (bit - idx * BITS_PER_INT)));\n};\n","/* Copyright 2023 the Miski authors. All rights reserved. MIT license. */\n\nimport * as bitfield from \"../bits/bitfield.js\";\nimport type { Bitfield } from \"../bits/bitfield.js\";\nimport type { ComponentInstance } from \"../component/instance.js\";\nimport type { QueryInstance } from \"../query/instance.js\";\nimport type { Entity } from \"../world.js\";\n\nexport class Archetype {\n  /** The Archetype's Component Bitfield */\n  readonly bitfield: Bitfield;\n  /** QueryInstances and their candidacy status*/\n  readonly candidateCache: Map<QueryInstance, boolean>;\n  /** The components associated with this archetype */\n  readonly components: ComponentInstance<any>[];\n  /** Entities which have entered this archetype since last refresh */\n  readonly entered: Set<Entity>;\n  /** Set of Entities which inhabit this Archetype */\n  readonly entities: Set<Entity>;\n  /** Entities which have exited this archetype since last refresh */\n  readonly exited: Set<Entity>;\n  /** `true` if the object is in a dirty state */\n  isDirty: boolean;\n\n  constructor(size: number, components: ComponentInstance<any>[], field?: Bitfield) {\n    this.bitfield = field ?? bitfield.fromObjects(size, \"id\", components);\n    this.candidateCache = new Map();\n    this.components = components;\n    this.entered = new Set();\n    this.entities = new Set();\n    this.exited = new Set();\n    this.isDirty = true;\n  }\n\n  /** The Archetype's unique identifier */\n  get id(): string {\n    return this.bitfield.toString();\n  }\n\n  /** `true` if this Archetype has no entities associated with it */\n  get isEmpty(): boolean {\n    return this.entities.size === 0;\n  }\n\n  /** The number of entities in the archetype */\n  get size(): number {\n    return this.entities.size;\n  }\n\n  /** Add an Entity to the Archetype */\n  addEntity(entity: Entity): Archetype {\n    this.entities.add(entity);\n    this.entered.add(entity);\n    this.isDirty = true;\n    return this;\n  }\n\n  /** Create a new Archetype from this Archetype */\n  clone(): Archetype {\n    return new Archetype(this.bitfield.length, this.components, bitfield.clone(this.bitfield));\n  }\n\n  /**\n   * Test this Archetype matches a given QueryInstance\n   * @param query The QueryInstance to test\n   * @returns `true` if the QueryInstance is a match\n   */\n  isCandidate(query: QueryInstance): boolean {\n    const cached = this.candidateCache.get(query);\n    if (cached !== undefined) return cached;\n    const status = this.bitfield.every(query.checkCandidacy);\n    this.candidateCache.set(query, status);\n    return status;\n  }\n\n  /** Clear entered/exited entities and set `isDirty` to `false` */\n  refresh(): Archetype {\n    this.entered.clear();\n    this.exited.clear();\n    this.isDirty = false;\n    return this;\n  }\n\n  /** Remove an Entity from the Archetype */\n  removeEntity(entity: Entity): Archetype {\n    this.entities.delete(entity);\n    this.exited.add(entity);\n    this.isDirty = true;\n    return this;\n  }\n\n  /** Serialize the Archetype to a string */\n  toString(replacer?: (this: any, key: string, value: any) => any, space?: string | number): string {\n    return JSON.stringify(\n      {\n        bitfield: this.bitfield.toString(),\n        components: this.components.map((inst) => inst.id).join(\",\"),\n        entities: [...this.entities.values()].join(\",\"),\n      },\n      replacer,\n      space,\n    );\n  }\n}\n","/* Copyright 2023 the Miski authors. All rights reserved. MIT license. */\n\nimport * as bitfield from \"../bits/bitfield.js\";\nimport type { Component } from \"../component/component.js\";\nimport type { ComponentInstance } from \"../component/instance.js\";\nimport type { QueryInstance } from \"../query/instance.js\";\nimport type { Query } from \"../query/query.js\";\nimport type { Entity } from \"../world.js\";\nimport { Archetype } from \"./archetype.js\";\n\nexport interface ArchetypeManagerSpec {\n  capacity: number;\n  components: Component<any>[];\n}\n\nexport class ArchetypeManager {\n  /** Map<Archetype.id, Archetype> */\n  archetypeMap: Map<string, Archetype> = new Map();\n  /** Archetype's indexed by Entity */\n  entityArchetypes: Archetype[];\n  /** The root/empty archetype */\n  rootArchetype: Archetype;\n\n  constructor(spec: ArchetypeManagerSpec) {\n    const { capacity, components } = spec;\n    this.rootArchetype = new Archetype(components.length, []);\n    this.archetypeMap = new Map();\n    this.archetypeMap.set(this.rootArchetype.id, this.rootArchetype);\n    this.entityArchetypes = Array.from({ length: capacity }, (_, i) => this.rootArchetype.addEntity(i as Entity));\n  }\n\n  /** @returns an entity's archetype or undefined if not found */\n  getArchetype(entity: Entity): Archetype | undefined {\n    return this.entityArchetypes[entity];\n  }\n\n  /** Returns an entity to the root archetype */\n  resetArchetype(entity: Entity): ArchetypeManager {\n    if (this.entityArchetypes[entity] === this.rootArchetype) return this;\n    this.entityArchetypes[entity]?.removeEntity(entity);\n    this.entityArchetypes[entity] = this.rootArchetype.addEntity(entity);\n    return this;\n  }\n\n  /** Performs various archetype maintenance */\n  refreshArchetypes(queries: Map<Query, QueryInstance>): ArchetypeManager {\n    /** @todo double loop isn't ideal */\n    for (const archetype of this.archetypeMap.values()) {\n      if (!archetype.isEmpty) {\n        for (const inst of queries.values()) {\n          if (!inst.archetypes.has(archetype) && archetype.isCandidate(inst)) {\n            inst.isDirty = true;\n            inst.archetypes.add(archetype);\n          }\n        }\n      }\n      archetype.refresh();\n    }\n    return this;\n  }\n\n  /** Replace an entity's archetype */\n  setArchetype(entity: Entity, archetype: Archetype): ArchetypeManager {\n    if (!this.archetypeMap.has(archetype.id)) throw new Error(\"Invalid archetype.\");\n    if (this.entityArchetypes[entity] === archetype) return this;\n    this.entityArchetypes[entity]?.removeEntity(entity);\n    this.entityArchetypes[entity] = archetype.addEntity(entity);\n    return this;\n  }\n\n  /**\n   * Update an Entity's archetype\n   * @param entity the entity to update\n   * @param components the components to toggle\n   * @returns The entity's resulting archetype\n   */\n  updateArchetype(entity: Entity, components: ComponentInstance<any>[]): Archetype {\n    /** @todo replace this with a graph */\n    const previousArchetype = this.entityArchetypes[entity];\n    previousArchetype?.removeEntity(entity);\n    const field = previousArchetype?.bitfield\n      ? bitfield.cloneWithToggle(previousArchetype.bitfield, \"id\", components)\n      : bitfield.fromObjects(bitfield.getSize(this.rootArchetype.bitfield), \"id\", components);\n    const id = field.toString();\n    let nextArchetype = this.archetypeMap.get(id);\n    if (!nextArchetype) {\n      nextArchetype = new Archetype(bitfield.getSize(this.rootArchetype.bitfield), components, field);\n      this.archetypeMap.set(id, nextArchetype);\n    }\n    this.entityArchetypes[entity] = nextArchetype.addEntity(entity);\n    return nextArchetype;\n  }\n}\n","/* Copyright 2023 the Miski authors. All rights reserved. MIT license. */\n\nimport type { Bitfield } from \"./bitfield.js\";\nimport * as bitfield from \"./bitfield.js\";\nimport { NO_INDEX } from \"./constants.js\";\nimport { getLowestSetPosition } from \"./utils.js\";\n\nexport type Bitpool = {\n  field: Bitfield;\n  nextAvailableIdx: number;\n  size: number;\n};\n\n/**\n * Creates a new BitPool with the specified size.\n * @param size The number of bits in the BitPool.\n * @returns A new BitPool instance.\n */\nexport const create = (size: number): Bitpool => {\n  const field = bitfield.create(size);\n  field.fill(0xffffffff);\n  return {\n    field,\n    nextAvailableIdx: 0,\n    size,\n  };\n};\n\n/**\n * Gets the population count (the number of set bits) in the BitPool.\n * @param bitpool The BitPool instance.\n * @returns The population count.\n */\nexport const getPopulationCount = ({ field }: Bitpool) => bitfield.getPopulationCount(field);\n\n/** @returns The maximum amount of bits in the array */\nexport const getSize = ({ size }: Bitpool) => size << 5;\n\n/**\n * Acquires an available bit in the BitPool, setting it to '0'.\n * @param bitpool The BitPool instance.\n * @returns The acquired bit's position or -1 if no bits are available.\n */\nexport const acquire = (bitpool: Bitpool) => {\n  const { nextAvailableIdx } = bitpool;\n  if (!~nextAvailableIdx) return NO_INDEX;\n  const index = bitpool.field[nextAvailableIdx] as number;\n  const position = getLowestSetPosition(index);\n  if (position >= bitpool.size) return NO_INDEX;\n  bitpool.field[nextAvailableIdx] &= ~(1 << position);\n  if (bitpool.field[nextAvailableIdx] === 0) {\n    bitpool.nextAvailableIdx = NO_INDEX;\n    for (let i = 0; i < bitpool.field.length; i++) {\n      if (bitpool.field[i] !== 0) {\n        bitpool.nextAvailableIdx = i;\n        break;\n      }\n    }\n  }\n  return (nextAvailableIdx << 5) + position;\n};\n\n/**\n * Releases a bit in the Bitpool, setting it back to '1'.\n * @param bitpool The Bitpool instance.\n * @param value The position of the bit to release.\n * @returns The updated Bitpool instance.\n */\nexport const release = (bitpool: Bitpool, value: number): Bitpool => {\n  const { index, position } = bitfield.getPosition(value);\n  if (index === NO_INDEX || position >= bitpool.size) return bitpool;\n  bitpool.field[index] |= 1 << position;\n  bitpool.nextAvailableIdx = index;\n  return bitpool;\n};\n","/* Copyright 2023 the Miski authors. All rights reserved. MIT license. */\n\nimport type { Entity } from \"../world.js\";\nimport type { Schema, SchemaStorage } from \"./schema.js\";\n\n/**\n * A storage proxy is a convenience method for setting entity's component\n * properties in a way which is type safe and flips the `changed` property\n * on the entity at the expense of performance vs. direct array access.\n */\nexport type StorageProxy<T extends Schema<T>> = Record<keyof T, number> & {\n  /** @returns the entity the proxy is currently pointed at */\n  getEntity(): Entity;\n  /**\n   * Change the proxy's cursor to a given entity\n   * @param entity The entity to change\n   * @throws If the entity is not a number\n   */\n  setEntity(entity: Entity): Entity;\n};\n\n/**\n * @internal\n * Create a new storage proxy object for a component instance\n * @param storage The component's storage object\n * @param changed The component's changed entity set\n * @returns A new storage proxy object\n * @throws if no storage or changed set are provided\n */\nexport function storageProxy<T extends Schema<T>>(storage: SchemaStorage<T>, changed: Set<Entity>): StorageProxy<T> {\n  if (!storage) throw new SyntaxError(\"Proxy can only be used on components, not tags.\");\n  if (!changed) throw new SyntaxError(\"Proxy requires a changed set.\");\n\n  /** The currently selected entity */\n  let entityId: Entity = 0 as Entity;\n\n  // allow the user to control which entity the proxy should modify\n  const proxy = {\n    getEntity(): Entity {\n      return entityId;\n    },\n    setEntity(entity: Entity): Entity {\n      if (isNaN(entity) || entity < 0) throw new TypeError(\"Expected entity to be a positive number.\");\n      entityId = entity;\n      return entityId;\n    },\n  } as StorageProxy<T>;\n\n  // Create a getter and setter for each storage property\n  for (const key in storage) {\n    Object.defineProperty(proxy, key, {\n      // eslint-disable-next-line no-loop-func\n      get: () => storage[key as keyof T][entityId],\n      // eslint-disable-next-line no-loop-func\n      set: (value: number) => {\n        if (storage[key as keyof T][entityId] !== value) {\n          storage[key as keyof T][entityId] = value;\n          changed.add(entityId);\n        }\n      },\n    });\n  }\n\n  return Object.freeze(proxy);\n}\n","/* Copyright 2023 the Miski authors. All rights reserved. MIT license. */\n\nimport { $_CHANGED, $_OWNERS } from \"../constants.js\";\nimport { isObject, isPositiveInt, isUint32 } from \"../utils/utils.js\";\nimport { storageProxy } from \"./proxy.js\";\nimport * as bitfield from \"../bits/bitfield.js\";\nimport type { Bitfield } from \"../bits/bitfield.js\";\nimport type { TypedArray } from \"../utils/utils.js\";\nimport type { StorageProxy } from \"./proxy.js\";\nimport type { Entity } from \"../world.js\";\nimport type { Component } from \"./component.js\";\nimport type { Schema, SchemaStorage } from \"./schema.js\";\n\ninterface ComponentInstanceSpec<T extends Schema<T>> {\n  /** The world's entity capacity */\n  capacity: number;\n  /** The component to instantiate */\n  component: Component<T>;\n  /** The component instance's identifier */\n  id: number;\n  /** The component's TypedArray storage object */\n  storage?: SchemaStorage<T> | undefined;\n}\n\nexport type ComponentInstance<T extends Schema<T>> = Component<T> &\n  Record<keyof T, TypedArray> & {\n    /** @internal */\n    [$_CHANGED]: Set<Entity>;\n    /** @internal */\n    [$_OWNERS]: Bitfield;\n    /** Entities who's properties have been changed via this.proxy since last refresh */\n    changed: IterableIterator<Entity>;\n    /** The number of entities which have this component instance */\n    count: number;\n    /** The instance's identifier */\n    id: number;\n    /** */\n    proxy: StorageProxy<T>;\n  };\n\n/**\n * Perform routine maintenance on a component instance\n * @param instance The ComponentInstance to refresh\n * @returns The ComponentInstance\n */\nexport function refreshComponentInstance<T extends Schema<T>>(instance: ComponentInstance<T>): ComponentInstance<T> {\n  instance[$_CHANGED].clear();\n  return instance;\n}\n\n/**\n * Create a new ComponentInstance.\n * A ComponentInstance is a Component tied to a World with storage\n * @param spec The ComponentInstance's specification object\n * @param spec.component The component to instantiate\n * @param spec.id The component instance's identifier\n * @param spec.storage The component's TypedArray storage object\n */\nexport function createComponentInstance<T extends Schema<T>>(\n  spec: ComponentInstanceSpec<T>,\n): Readonly<ComponentInstance<T>> {\n  const { capacity, component, id, storage } = spec;\n  if (!isPositiveInt(capacity)) throw new SyntaxError(\"Capacity must be integer > 0.\");\n  if (!component) throw new Error(\"Component instantiation requires as component!\");\n  if (!isUint32(id)) throw new SyntaxError(\"Component ID is invalid.\");\n  if (storage && !isObject(storage)) throw new TypeError(\"Component storage is malformed.\");\n\n  const changed: Set<Entity> = new Set();\n  const owners: Bitfield = bitfield.create(capacity);\n\n  const instance = Object.create(component, {\n    [$_CHANGED]: {\n      value: changed,\n      configurable: false,\n      enumerable: false,\n      writable: false,\n    },\n    [$_OWNERS]: {\n      value: owners,\n      configurable: false,\n      enumerable: false,\n      writable: false,\n    },\n    changed: {\n      get() {\n        return changed.values();\n      },\n    },\n    count: {\n      get() {\n        return bitfield.getPopulationCount(owners);\n      },\n    },\n    id: {\n      value: id,\n      configurable: false,\n      enumerable: true,\n      writable: false,\n    },\n  }) as ComponentInstance<T>;\n\n  if (storage) {\n    // create instance.proxy\n    Object.defineProperty(instance, \"proxy\", {\n      value: storageProxy(storage, changed),\n      configurable: false,\n      enumerable: true,\n      writable: false,\n    });\n\n    // assign raw storage\n    Object.keys(storage).forEach((k) => {\n      Object.defineProperty(instance, k, {\n        value: storage[k as keyof T],\n      });\n    });\n  }\n\n  return Object.freeze(instance);\n}\n","/* Copyright 2023 the Miski authors. All rights reserved. MIT license. */\n\nimport * as bitpool from \"../bits/bitpool.js\";\nimport type { TypedArray } from \"../utils/utils.js\";\nimport type { Entity } from \"../world.js\";\n\ntype SparseFacade<T extends TypedArray> = T & {\n  get(entity: Entity): T[0] | undefined;\n  set(entity: Entity, value: T[0]): boolean;\n  delete(entity: Entity): boolean;\n};\n\n/**\n * @param dense the typed array to apply the facade to\n * @returns A proxy to the dense array\n */\nexport function sparseFacade<T extends TypedArray>(dense: T): SparseFacade<T> {\n  /** Map<Entity, Dense Array Index> */\n  const sparse = new Map<Entity, number>();\n\n  /** Array of available indexes in dense */\n  const available = bitpool.create(dense.length);\n\n  /** @returns the entity's value from the dense array or undefined if non-existant */\n  const get = (entity: Entity) => dense[sparse.get(entity) ?? -1];\n\n  /** @returns `false` if dense array is full, `true` if value set successfully */\n  const set = (entity: Entity, value: T[0]): boolean => {\n    const idx = sparse.get(entity) ?? bitpool.acquire(available);\n    if (idx === undefined) return false;\n    dense[idx] = value;\n    sparse.set(entity, idx);\n    return true;\n  };\n\n  /** @returns `false` if the entity isn't already stored, `true` if deleted successfully */\n  const deleteProperty = (entity: Entity): boolean => {\n    const idx = sparse.get(entity);\n    if (idx === undefined) return false;\n    dense[idx] = 0;\n    sparse.delete(entity);\n    bitpool.release(available, idx);\n    return true;\n  };\n\n  return new Proxy(dense, {\n    get: (_target: T, key: string | symbol) => get(key as unknown as Entity),\n    set: (_target: T, key: string | symbol, value: T[0]) => set(key as unknown as Entity, value),\n    deleteProperty: (_target: T, key: string | symbol) => deleteProperty(key as unknown as Entity),\n  }) as SparseFacade<T>;\n}\n","/* Copyright 2023 the Miski authors. All rights reserved. MIT license. */\n\nimport { sparseFacade } from \"./sparse-facade.js\";\nimport type { Component } from \"./component.js\";\nimport type { Schema, SchemaStorage } from \"./schema.js\";\nimport type { TypedArrayConstructor } from \"../utils/utils.js\";\n\nexport interface ComponentBufferSpec {\n  /** The maximum number of Entities in the World */\n  capacity: number;\n  /** An array of Components to partition to buffer for */\n  components: Component<any>[];\n}\n\n/** Serialized component partition property object */\nexport type PartitionProperty = {\n  [propertyName: string]: [offset: number, typedArrayType: string, maxEntities: number | null];\n};\n\n/** Serialized component buffer partition object */\nexport type PartitionsObject = {\n  [componentName: string]: PartitionProperty;\n};\n\nexport interface ComponentBufferData {\n  /** The ArrayBuffer as a string */\n  buffer: string;\n  /** The maximum number of Entities in the World */\n  capacity: number;\n  /** Map of components and the byteOffset of their schema properties */\n  partitions: PartitionsObject;\n}\n\n/**\n * Calculate the total required storage space for all component schemas\n * @param capacity The maximum number of Entities in the World\n * @param components An array of Components to create partitions for\n * @returns The required ArrayBuffer size in bytes\n */\nexport function getTotalStorageSize(capacity: number, components: Component<any>[]): number {\n  return components.reduce(<T extends Schema<T>>(total: number, component: Component<T>): number => {\n    const { size } = component;\n    if (!size || !isFinite(size) || size < 0) return total;\n    return total + size * capacity;\n  }, 0);\n}\n\n/**\n * Partitions the ComponentBuffer into individual TypedArrays for each Component\n * @param buffer The ComponentBuffer to partition\n * @param capacity The maximum number of Entities in the World\n * @param components An array of Components to create partitions for\n * @returns A map of SchemaStorage objects keyed by the Component object\n */\nexport function partitionComponentBuffer(\n  buffer: ComponentBuffer,\n  capacity: number,\n  components: Component<any>[],\n): Map<Component<any>, SchemaStorage<any>> {\n  const partitions = new Map<Component<any>, SchemaStorage<any>>();\n  let byteOffset = 0;\n  for (const component of components) {\n    const { maxEntities, schema } = component;\n    // Tags don't need partitions\n    if (!schema) return partitions;\n    // maxEntities should always be less than capacity\n    const requiredSize = maxEntities ?? capacity;\n    // the result in partition object\n    const partition = {} as SchemaStorage<any>;\n    // loop though each item in the schema and create a new PartitionProperty object\n    for (const [key, value] of Object.entries(schema)) {\n      // `value` can be a TypedArrayConstructor, or [TypedArrayConstructor, initialValue]\n      let typedArrayConstructor = value as TypedArrayConstructor;\n      let initialValue = 0;\n      if (Array.isArray(value)) [typedArrayConstructor, initialValue] = value as [TypedArrayConstructor, number];\n      // Create the underlying TypedArray storage\n      const dense = new typedArrayConstructor(buffer, byteOffset, requiredSize);\n      partition[key] = maxEntities === null ? dense : sparseFacade(dense);\n      partition[key]?.fill(initialValue as never);\n      // increment the global ArrayBuffer byteOffset\n      byteOffset += typedArrayConstructor.BYTES_PER_ELEMENT * requiredSize;\n    }\n    partitions.set(component, partition);\n  }\n  return partitions;\n}\n\n/**\n * Serialize a ComponentBuffer object into a stringify-able object\n * @param buffer The ComponentBuffer to serialize\n * @returns A new ComponentBufferData object\n */\nexport function serializeComponentBuffer(buffer: ComponentBuffer): ComponentBufferData {\n  const { capacity, partitions } = buffer;\n\n  // Reduce the partitions to { componentName: { propertyName: byteOffset, ... }, ... }\n  const parts: PartitionsObject = {};\n  for (const [component, storage] of partitions) {\n    const props: PartitionProperty = {};\n    for (const [name, arr] of Object.entries(storage)) {\n      props[name] = [arr.byteOffset, arr.constructor.name, component.maxEntities];\n    }\n    parts[component.name] = props;\n  }\n\n  return {\n    buffer: new TextDecoder().decode(buffer),\n    capacity,\n    partitions: parts,\n  };\n}\n\nexport class ComponentBuffer extends ArrayBuffer {\n  /** Maximum number of entities in the world */\n  readonly capacity: number;\n\n  /** Components and their respective TypedArray storage */\n  readonly partitions: Map<Component<any>, SchemaStorage<any>> = new Map();\n\n  /**\n   * Create a properly sized ArrayBuffer to hold all a world's component's data.\n   * @param spec The component buffer's specification object\n   * @param spec.capacity The world's entity capacity\n   * @param spec.components The components which the buffer will contain\n   */\n  constructor(spec: ComponentBufferSpec) {\n    const { capacity, components } = spec;\n    super(getTotalStorageSize(capacity, components));\n    this.capacity = capacity;\n    this.partitions = partitionComponentBuffer(this, capacity, components);\n  }\n}\n","/* Copyright 2023 the Miski authors. All rights reserved. MIT license. */\n\nimport { $_OWNERS } from \"../constants.js\";\nimport { createComponentInstance, refreshComponentInstance } from \"./instance.js\";\nimport { ComponentBuffer } from \"./buffer.js\";\nimport * as bitfield from \"../bits/bitfield.js\";\nimport type { Entity } from \"../world.js\";\nimport type { TypedArrayConstructor } from \"../utils/utils.js\";\nimport type { Component } from \"./component.js\";\nimport type { ComponentInstance } from \"./instance.js\";\nimport type { Schema, SchemaProps } from \"./schema.js\";\n\n/** [component name]: component instance */\nexport type ComponentRecord = Record<string, ComponentInstance<any>>;\n\nexport type ComponentMap = Map<Component<any>, ComponentInstance<any>>;\n\nexport interface ComponentManagerSpec {\n  capacity: number;\n  components: Component<any>[];\n}\n\nfunction instantiate(buffer: ComponentBuffer, capacity: number, components: Component<any>[]) {\n  return new Map<Component<any>, ComponentInstance<any>>(\n    components.map((component, id) => [\n      component,\n      createComponentInstance({\n        capacity,\n        component,\n        id,\n        storage: buffer.partitions.get(component),\n      }),\n    ]),\n  );\n}\n\n/** @todo better async? */\nexport function addEntity<T extends Schema<T>>(\n  instance: ComponentInstance<T>,\n  entity: Entity,\n  properties?: Record<string, SchemaProps<T>>,\n) {\n  const { maxEntities, name, schema } = instance;\n  if (maxEntities && instance.count >= maxEntities) {\n    throw new Error(`Component \"${name}\".maxEntities reached.`);\n  }\n  if (bitfield.isSet(instance[$_OWNERS], entity)) return null;\n  bitfield.toggle(instance[$_OWNERS], entity);\n  // set properties\n  if (schema) {\n    /** @todo Object.entries creates an array. */\n    Object.entries(schema).forEach(([key, value]) => {\n      instance[key as keyof T][entity] = properties\n        ? (properties[name] as SchemaProps<T>)[key as keyof T] ?? (value as [TypedArrayConstructor, number])[1] ?? 0\n        : (value as [TypedArrayConstructor, number])[1] ?? 0;\n    });\n  }\n  return instance;\n}\n\n/** @todo better async? */\nexport function removeEntity<T extends Schema<T>>(instance: ComponentInstance<T>, entity: Entity) {\n  const { maxEntities, schema } = instance;\n  if (!bitfield.isSet(instance[$_OWNERS], entity)) return null;\n  bitfield.toggle(instance[$_OWNERS], entity);\n  if (schema) {\n    /** @todo Object.entries creates an array. */\n    Object.entries(schema).forEach(([key, prop]) => {\n      const storage = instance[key as keyof T];\n      if (storage) {\n        if (maxEntities) {\n          delete storage[entity];\n        } else {\n          storage[entity] = Array.isArray(prop) ? (prop[1] as number) : 0;\n        }\n      }\n    });\n  }\n  return instance;\n}\n\nexport class ComponentManager {\n  readonly buffer: ComponentBuffer;\n  readonly componentMap: Map<Component<any>, ComponentInstance<any>>;\n\n  constructor(spec: ComponentManagerSpec) {\n    const { capacity, components } = spec;\n    this.buffer = new ComponentBuffer({ capacity, components });\n    this.componentMap = instantiate(this.buffer, capacity, components);\n  }\n\n  addComponentsToEntity(\n    components: Component<any>[],\n  ): (entity: Entity, properties?: Record<string, SchemaProps<unknown>>) => ComponentInstance<any>[] {\n    const instances = this.getInstances(components).filter(Boolean) as ComponentInstance<any>[];\n    if (instances.length !== components.length) throw new Error(\"Some components are not registered in this world!\");\n    return (entity: Entity, properties?: Record<string, SchemaProps<unknown>>) => {\n      return instances\n        .map((instance) => addEntity(instance, entity, properties))\n        .filter(Boolean) as ComponentInstance<any>[];\n    };\n  }\n\n  removeComponentsFromEntity(components: Component<any>[]) {\n    const instances = this.getInstances(components).filter(Boolean) as ComponentInstance<any>[];\n    if (instances.length !== components.length) throw new Error(\"Some components are not registered in this world!\");\n    return (entity: Entity) => {\n      return instances.map((instance) => removeEntity(instance, entity)).filter(Boolean) as ComponentInstance<any>[];\n    };\n  }\n\n  getBuffer(): ArrayBuffer {\n    return this.buffer.slice(0);\n  }\n\n  getInstance<T extends Schema<T>>(component: Component<T>): ComponentInstance<T> | undefined {\n    return this.componentMap.get(component);\n  }\n\n  getInstances(components: Component<any>[]): (ComponentInstance<any> | undefined)[] {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    return components.map(this.getInstance, this);\n  }\n\n  setBuffer(source: ArrayBuffer): ComponentManager {\n    if (source.byteLength !== this.buffer.byteLength) {\n      throw new Error(\"setBuffer: byteLength mismatch!\");\n    }\n    const view = new Uint8Array(source);\n    const target = new Uint8Array(this.buffer);\n    target.set(view);\n    return this;\n  }\n\n  refreshComponents(): ComponentManager {\n    this.componentMap.forEach(refreshComponentInstance);\n    return this;\n  }\n\n  export() {\n    return {\n      buffer: this.buffer,\n      components: [...this.componentMap.values()],\n    };\n  }\n}\n","/* Copyright 2023 the Miski authors. All rights reserved. MIT license. */\n\nimport { createQueryInstance } from \"./instance.js\";\nimport { Query } from \"./query.js\";\nimport type { Archetype } from \"../archetype/archetype.js\";\nimport type { Component } from \"../component/component.js\";\nimport type { ComponentInstance } from \"../component/instance.js\";\nimport type { ComponentManager, ComponentRecord } from \"../component/manager.js\";\nimport type { Entity } from \"../world.js\";\nimport type { QueryInstance } from \"./instance.js\";\n\n/** @todo find a nicer way of doing this */\n// NOTE: The following functions are used to avoid flatmap which incurs a GC penalty\n\nfunction _flattenEntered(this: Set<Entity>, { entered }: Archetype) {\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  entered.forEach(this.add, this);\n}\n\nfunction _flattenEntities(this: Set<Entity>, { entities }: Archetype) {\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  entities.forEach(this.add, this);\n}\n\nfunction _flattenExited(this: Set<Entity>, { exited }: Archetype) {\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  exited.forEach(this.add, this);\n}\n\nfunction refreshQuery(query: QueryInstance) {\n  query.isDirty = false;\n}\n\nexport interface QueryManagerSpec {\n  componentManager: ComponentManager;\n}\n\nexport class QueryManager {\n  /** The components, and their instances, of a given world */\n  componentMap: Map<Component<any>, ComponentInstance<any>>;\n  /** Cache for Entities which match each QueryInstance */\n  entityCache: Map<QueryInstance, Set<Entity>>;\n  /** Map of registered Queries and their instances */\n  queryMap: Map<Query, QueryInstance>;\n\n  /**\n   * Creates a new QueryManager\n   *\n   * QueryManagers are responsible for:\n   *  - registering and instantiating queries\n   *  - getting components and entities from query instances\n   *\n   * @param spec the manager's specification object\n   */\n  constructor(spec: QueryManagerSpec) {\n    const { componentManager } = spec;\n    this.componentMap = componentManager.componentMap;\n    this.entityCache = new Map();\n    this.queryMap = new Map();\n  }\n\n  /** @returns the components associated with a query */\n  getComponentsFromQuery(query: Query): ComponentRecord {\n    return this.getQueryInstance(query).components;\n  }\n\n  /** @returns an array of Entities which have entered this query since last refresh */\n  getEnteredFromQuery(query: Query): () => IterableIterator<Entity> {\n    const res: Set<Entity> = new Set();\n    const instance = this.getQueryInstance(query);\n    return (): IterableIterator<Entity> => {\n      res.clear();\n      instance.archetypes.forEach(_flattenEntered, res);\n      return res.values();\n    };\n  }\n\n  /** @returns an array of Entities which match the query */\n  getEntitiesFromQuery(query: Query): () => IterableIterator<Entity> {\n    const instance = this.getQueryInstance(query);\n    const cached = this.entityCache.get(instance) ?? this.entityCache.set(instance, new Set()).get(instance)!;\n    return () => {\n      const { archetypes, isDirty } = instance;\n      if (isDirty === true || !cached.size) {\n        // if query has new Archetypes, clear cache and do full sweep\n        cached.clear();\n        archetypes.forEach(_flattenEntities, cached);\n      } else {\n        // else just update the dirty archetypes\n        archetypes.forEach((archetype) => {\n          if (archetype.isDirty === true) {\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            archetype.entered.forEach(cached.add, cached);\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            archetype.exited.forEach(cached.delete, cached);\n          }\n        });\n      }\n      return cached.values();\n    };\n  }\n\n  /** @returns an array of Entities which have been removed from this query since last refresh */\n  getExitedFromQuery(query: Query): () => IterableIterator<Entity> {\n    const res: Set<Entity> = new Set();\n    const instance = this.getQueryInstance(query);\n    return (): IterableIterator<Entity> => {\n      res.clear();\n      instance.archetypes.forEach(_flattenExited, res);\n      return res.values();\n    };\n  }\n\n  /** @returns an instantiated Query */\n  getQueryInstance(query: Query): QueryInstance {\n    return this.queryMap.get(query) ?? this.registerQuery(query);\n  }\n\n  /** Register a Query in the world, producing a QueryInstance */\n  registerQuery(query: Query): QueryInstance {\n    if (!(query instanceof Query)) throw new Error(\"Object is not a valid query.\");\n    const cached = this.queryMap.get(query);\n    if (cached) return cached;\n    const instance = createQueryInstance({ componentMap: this.componentMap, query });\n    this.queryMap.set(query, instance);\n    return instance;\n  }\n\n  /** Perform routine maintenance on each registered query */\n  refreshQueries(): QueryManager {\n    this.queryMap.forEach(refreshQuery);\n    return this;\n  }\n\n  export() {\n    return {\n      queries: [...this.queryMap.values()],\n    };\n  }\n}\n","/* Copyright 2023 the Miski authors. All rights reserved. MIT license. */\n\nimport type { Archetype } from \"../archetype/archetype.js\";\nimport type { Bitfield } from \"../bits/bitfield.js\";\nimport * as bitfield from \"../bits/bitfield.js\";\nimport { intersectBits } from \"../bits/utils.js\";\nimport type { Component } from \"../component/component.js\";\nimport type { ComponentInstance } from \"../component/instance.js\";\nimport type { Schema } from \"../component/schema.js\";\nimport type { Query } from \"./query.js\";\n\ninterface QueryInstanceSpec {\n  componentMap: Map<Component<any>, ComponentInstance<any>>;\n  query: Query;\n}\n\nexport interface QueryInstance extends Query {\n  /** A bitfield for the AND match criteria */\n  and: Readonly<Bitfield>;\n  /** */\n  archetypes: Set<Archetype>;\n  /** */\n  checkCandidacy: (target: number, idx: number) => boolean;\n  /** */\n  components: Record<string, ComponentInstance<any>>;\n  /**\n   * `true` if the object is in a dirty state\n   *\n   * A query becomes dirty when an archetype is added or removed\n   */\n  isDirty: boolean;\n  /** A bitfield for the OR match criteria */\n  or: Readonly<Bitfield>;\n  /** A bitfield for the NOT match criteria */\n  not: Readonly<Bitfield>;\n}\n\nexport function createQueryInstance(spec: QueryInstanceSpec): QueryInstance {\n  const { componentMap, query } = spec;\n  const { all, any, none } = query;\n\n  const getComponentInstances = <T extends Schema<T>>(\n    arr: ComponentInstance<any>[],\n    component: Component<T>,\n    idx: number,\n  ) => {\n    const inst = componentMap.get(component);\n    if (!inst) throw new Error(`Component ${component.name} not found.`);\n    arr[idx] = inst as ComponentInstance<T>;\n    return arr;\n  };\n\n  const length = componentMap.size;\n\n  const _allInstances = all.reduce(getComponentInstances, new Array(all.length) as ComponentInstance<any>[]);\n  const and = bitfield.fromObjects(length, \"id\", _allInstances);\n\n  const _anyInstances = any.reduce(getComponentInstances, new Array(any.length) as ComponentInstance<any>[]);\n  const or = bitfield.fromObjects(length, \"id\", _anyInstances);\n\n  const _noneInstances = none.reduce(getComponentInstances, new Array(none.length) as ComponentInstance<any>[]);\n  const not = bitfield.fromObjects(length, \"id\", _noneInstances);\n\n  /** The components matched by the and/or bitfields */\n  const components = Object.fromEntries([..._allInstances, ..._anyInstances].map((c) => [c.name, c]));\n\n  const archetypes: Set<Archetype> = new Set();\n\n  const checkCandidacy = (target: number, idx: number): boolean => {\n    const OR = or[idx] === 0 || intersectBits(target, or[idx]) > 0;\n    if (!OR) return false;\n    const AND = intersectBits(target, and[idx]) === and[idx];\n    if (!AND) return false;\n    return intersectBits(target, not[idx]) === 0;\n  };\n\n  return Object.assign(Object.create(query), {\n    isDirty: true,\n    archetypes,\n    and,\n    checkCandidacy,\n    components,\n    not,\n    or,\n  }) as QueryInstance;\n}\n","/* Copyright 2023 the Miski authors. All rights reserved. MIT license. */\n\nimport { ArchetypeManager } from \"./archetype/manager.js\";\nimport * as bitfield from \"./bits/bitfield.js\";\nimport type { Bitpool } from \"./bits/bitpool.js\";\nimport * as bitpool from \"./bits/bitpool.js\";\nimport type { Component } from \"./component/component.js\";\nimport type { ComponentInstance } from \"./component/instance.js\";\nimport type { ComponentRecord } from \"./component/manager.js\";\nimport { ComponentManager, removeEntity } from \"./component/manager.js\";\nimport type { Schema, SchemaProps } from \"./component/schema.js\";\nimport { $_OWNERS, VERSION } from \"./constants.js\";\nimport { QueryManager } from \"./query/manager.js\";\nimport { Query } from \"./query/query.js\";\nimport { isObject, isPositiveInt, isUint32, Opaque } from \"./utils/utils.js\";\n\n/** Entities are indexes of an EntityArray. An Entity is just an integer. */\nexport type Entity = Opaque<number, \"Entity\">;\n\n/** The object returned from `world.save();` */\nexport interface WorldData {\n  /** The world's component storage buffer */\n  buffer: ArrayBuffer;\n  /** The maximum number of entities allowed in the world */\n  capacity: number;\n  /** The Miski version of the creating world */\n  version: string;\n}\n\nexport interface WorldSpec {\n  /** The maximum number of entities allowed in the world */\n  capacity: number;\n  /** Components to instantiate in the world */\n  components: Component<any>[];\n}\n\n/**\n * Creates a valid WorldSpec (if possible) from an object\n * @param spec The object to examine\n * @returns A new WorldSpec object\n * @throws On invalid WorldSpec properties\n */\nfunction validateWorldSpec(spec: WorldSpec): Required<WorldSpec> {\n  // check spec exists\n  if (!spec || !isObject(spec)) {\n    throw new SyntaxError(\"World creation requires a specification object.\");\n  }\n  const { capacity, components } = spec;\n  // check capacity\n  if (!isPositiveInt(capacity)) {\n    throw new SyntaxError(\"World: spec.capacity invalid.\");\n  }\n  // check components\n  if (!Array.isArray(components) || !components.every((c) => Object.prototype.hasOwnProperty.call(c, \"name\"))) {\n    throw new TypeError(\"World: spec.components invalid.\");\n  }\n  return { ...spec, capacity: Math.ceil(capacity), components: [...new Set(components)] };\n}\n\nexport class World {\n  private readonly archetypeManager: ArchetypeManager;\n  private readonly componentManager: ComponentManager;\n  private readonly queryManager: QueryManager;\n\n  /** Pool of Entity states */\n  private readonly entities: Bitpool;\n\n  /** The maximum number of entities the world can hold */\n  readonly capacity: number;\n\n  /** Miski version */\n  readonly version = VERSION;\n\n  /**\n   * Create a new World object\n   * @param spec An WorldSpec object\n   * @param spec.capacity The maximum number of entities allowed in the world\n   * @param spec.components An array of components to instantiate in the world\n   * @throws If the spec is invalid\n   */\n  constructor(spec: WorldSpec) {\n    const { capacity, components } = validateWorldSpec(spec);\n    this.capacity = capacity;\n    this.entities = bitpool.create(capacity);\n    this.archetypeManager = new ArchetypeManager({ capacity, components });\n    this.componentManager = new ComponentManager({ capacity, components });\n    this.queryManager = new QueryManager({ componentManager: this.componentManager });\n    this.refresh();\n    Object.freeze(this);\n  }\n\n  /** @returns the number of active entities */\n  get residents(): number {\n    const { capacity } = this;\n    const { field } = this.entities;\n    const { getPopulationCount, getSize } = bitfield;\n    return capacity - (getPopulationCount(field) - (getSize(field) - capacity));\n  }\n\n  /** @returns the number of available entities */\n  get vacancies(): number {\n    return this.capacity - this.residents;\n  }\n\n  /**\n   * Creates a function to add a given set of components to an entity\n   * @param components One or more components to add\n   * @returns A function which takes an entity and optional properties object\n   * @throws if one or more components are not registered in this world\n   */\n  addComponentsToEntity(...components: Component<any>[]) {\n    const cb = this.componentManager.addComponentsToEntity(components);\n    return (entity: Entity, properties?: Record<string, SchemaProps<unknown>>): World => {\n      if (!this.isValidEntity(entity)) throw new SyntaxError(`Entity ${entity as number} is not valid!`);\n      this.archetypeManager.updateArchetype(entity, cb(entity, properties));\n      return this;\n    };\n  }\n\n  /** @returns the next available Entity or `undefined` if no Entity is available */\n  createEntity(): Entity | undefined {\n    if (this.residents >= this.capacity) return;\n    const entity = bitpool.acquire(this.entities) as Entity;\n    if (entity < 0) return;\n    this.archetypeManager.setArchetype(entity, this.archetypeManager.rootArchetype);\n    return entity;\n  }\n\n  /**\n   * Remove and recycle an Entity\n   * @param entity the entity to destroy\n   * @returns the world\n   * @throws if the entity is invalid\n   */\n  destroyEntity(entity: Entity): World {\n    if (!this.isValidEntity(entity)) throw new SyntaxError(`Entity ${entity as number} is not valid!`);\n    this.archetypeManager.entityArchetypes[entity]?.components.forEach((instance) => {\n      removeEntity(instance, entity);\n    });\n    this.archetypeManager.resetArchetype(entity);\n    bitpool.release(this.entities, entity);\n    return this;\n  }\n\n  /**\n   * Get all the changed entities from a set of components\n   * @param components The components to collect changed entities from\n   * @returns An array of entities\n   * @throws if one or more components are not registered in this world\n   */\n  getChangedFromComponents(...components: Component<any>[]): () => IterableIterator<Entity> {\n    const instances = this.componentManager.getInstances(components).filter(Boolean) as ComponentInstance<any>[];\n    if (instances.length !== components.length) throw new Error(\"Not all components registered!\");\n    const changedSets = Object.values(instances).map((inst) => inst.changed);\n    const entities = new Set<Entity>();\n    return (): IterableIterator<Entity> => {\n      entities.clear();\n      for (const changed of changedSets) {\n        for (const entity of changed) {\n          entities.add(entity);\n        }\n      }\n      return entities.values();\n    };\n  }\n\n  /**\n   * Get all the changed entities from a query\n   * @param query the query to collect changed entities from\n   * @param arr an optional array to be emptied and recycled\n   * @returns an array of entities\n   * @throws if query is invalid\n   */\n  getChangedFromQuery(query: Query): () => IterableIterator<Entity> {\n    const { components } = this.queryManager.getQueryInstance(query);\n    const changedSets = Object.values(components).map((inst) => inst.changed);\n    const entities = new Set<Entity>();\n    return (): IterableIterator<Entity> => {\n      entities.clear();\n      for (const changed of changedSets) {\n        for (const entity of changed) {\n          entities.add(entity);\n        }\n      }\n      return entities.values();\n    };\n  }\n\n  /**\n   * Get this world's instance of a component\n   * @param component The component to retrieve the instance of\n   * @returns The component instance or undefined if the component is not registered\n   */\n  getComponentInstance<T extends Schema<T>>(component: Component<T>): ComponentInstance<T> | undefined {\n    return this.componentManager.componentMap.get(component);\n  }\n\n  /**\n   * Get this world's instances of a set of components\n   * @param component The component to retrieve the instance of\n   * @returns An array of component instances or undefined if the component is not registered\n   */\n  getComponentInstances(...components: Component<any>[]): (ComponentInstance<any> | undefined)[] {\n    return this.componentManager.getInstances(components);\n  }\n\n  /**\n   * Get all of the component properties of a given entity\n   * @param entity The entity to retrieve the properties of\n   * @returns An object where keys are component names and properties are the entity's properties\n   */\n  getEntityProperties(entity: Entity): Record<string, boolean | SchemaProps<unknown>> {\n    const archetype = this.archetypeManager.getArchetype(entity);\n    if (!archetype) return {};\n    const { components } = archetype;\n    return Object.fromEntries(\n      components.map(<T extends Schema<T>>(component: ComponentInstance<T>) => {\n        const { name, schema } = component;\n        let props: boolean | SchemaProps<T> = true;\n        if (schema) {\n          props = Object.fromEntries(\n            Object.keys(schema).map((key) => [key as keyof T, component[key as keyof T]?.[entity]]),\n          ) as SchemaProps<T>;\n        }\n        return [name, props];\n      }),\n    );\n  }\n\n  /**\n   * Get all the components positively associated with a query\n   * @param query The query to get the components from\n   * @returns An object where keys are component names and properties are component instances\n   * @throws If the query is invalid\n   */\n  getQueryComponents(query: Query): ComponentRecord {\n    return this.queryManager.getComponentsFromQuery(query);\n  }\n\n  /**\n   * Get all the entities which have entered the query since the last refresh\n   * @param query The query to get the entities from\n   * @returns An iterator of entities\n   * @throws If the query is invalid\n   */\n  getQueryEntered(query: Query): () => IterableIterator<Entity> {\n    return this.queryManager.getEnteredFromQuery(query);\n  }\n\n  /**\n   * Get all the entities which match a query\n   * @param query The query to get the entities from\n   * @returns An iterator of entities\n   * @throws If the query is invalid\n   */\n  getQueryEntities(query: Query): () => IterableIterator<Entity> {\n    return this.queryManager.getEntitiesFromQuery(query);\n  }\n\n  /**\n   * Get all the entities which have exited the query since the last refresh\n   * @param query The query to get the entities from\n   * @returns An iterator of entities\n   * @throws If the query is invalid\n   */\n  getQueryExited(query: Query): () => IterableIterator<Entity> {\n    return this.queryManager.getExitedFromQuery(query);\n  }\n\n  /**\n   * Create a function to test entities for a given component\n   * @param component The component to test for\n   * @returns A function which takes an entity and returns\n   *     true if the entity has the component, false if it does not\n   *     or null if the entity does not exist.\n   * @throws if the component is not registered in this world\n   */\n  hasComponent<T extends Schema<T>>(component: Component<T>): (entity: Entity) => boolean | null {\n    const instance = this.componentManager.getInstance(component);\n    if (!instance) throw new Error(\"Component is not registered.\");\n    return (entity: Entity) => bitfield.isSet(instance[$_OWNERS], entity);\n  }\n\n  /**\n   * Create a function to test entities for a given component\n   * @param components The components to test for\n   * @returns A function which takes an entity and returns an array of\n   *     true if the entity has the component, false if it does not\n   *     or null if the entity does not exist.\n   * @throws if one or more component is not registered in this world\n   */\n  hasComponents(...components: Component<any>[]): (entity: Entity) => (boolean | null)[] {\n    const instances = this.componentManager.getInstances(components).filter(Boolean) as ComponentInstance<any>[];\n    if (instances.length !== components.length) throw new Error(\"Not all components registered!\");\n    return (entity: Entity): (boolean | null)[] => {\n      return instances.map((component) => bitfield.isSet(component[$_OWNERS], entity));\n    };\n  }\n\n  /**\n   * Test if an entity is active in the world\n   * @return a boolean or null if the entity is invalid\n   *\n   */\n  isEntityActive(entity: Entity): boolean | null {\n    if (!this.isValidEntity(entity)) return null;\n    return bitfield.isSet(this.entities.field, entity);\n  }\n\n  /** @return `true` if the given entity is valid for the given capacity */\n  isValidEntity(entity: Entity): entity is Entity {\n    return isUint32(entity) && entity < bitfield.getSize(this.entities.field);\n  }\n\n  /**\n   * Swap the ComponentBuffer of one world with this world\n   * @returns the world\n   * @throws if the capacity or version of the data to load is mismatched\n   */\n  load(data: WorldData): World {\n    const { buffer, capacity, version } = data;\n    if (version !== this.version) {\n      throw new Error(`Version mismatch. Trying to load ${version} data into ${this.version} world.`);\n    }\n    if (capacity !== this.capacity) {\n      throw new Error(`Capacity mismatch. Data requires a world with a capacity of ${capacity}.`);\n    }\n    this.componentManager.setBuffer(buffer);\n    this.refresh();\n    return this;\n  }\n\n  /** Runs various world maintenance functions */\n  refresh(): World {\n    this.queryManager.refreshQueries();\n    this.archetypeManager.refreshArchetypes(this.queryManager.queryMap);\n    this.componentManager.refreshComponents();\n    return this;\n  }\n\n  /**\n   * Creates a function to remove a given set of components from an entity\n   * @param components One or more components to remove\n   * @returns A function which takes an entity\n   * @throws if one or more components are not registered in this world\n   */\n  removeComponentsFromEntity(...components: Component<any>[]): (entity: Entity) => World {\n    const remover = this.componentManager.removeComponentsFromEntity(components);\n    return (entity: Entity) => {\n      if (!this.isValidEntity(entity)) throw new SyntaxError(`Entity ${entity as number} is not valid!`);\n      this.archetypeManager.updateArchetype(entity, remover(entity));\n      return this;\n    };\n  }\n\n  /** Export various bits of data about the world */\n  save(): WorldData {\n    return Object.freeze({\n      buffer: this.componentManager.getBuffer(),\n      capacity: this.capacity,\n      version: this.version,\n    });\n  }\n}\n"],"names":["FORBIDDEN_NAMES","Object","freeze","Set","VALID_NAME_PATTERN","EMPTY_ARRAY","$_CHANGED","Symbol","$_OWNERS","isUint32","n","isNaN","isPositiveInt","isTypedArrayConstructor","object","Boolean","prototype","hasOwnProperty","call","isValidName","str","length","has","test","isObject","Array","isArray","_validateSchemaEntry","name","value","TAC","_validateProps","isValidSchema","schema","undefined","entries","every","_","byteSum","total","BYTES_PER_ELEMENT","Component","isTag","maxEntities","size","constructor","spec","SyntaxError","this","values","reduce","Number","NaN","calculateSchemaSize","_validateQueryArrays","component","Query","all","any","none","System","system","query","init","world","components","getQueryComponents","getEntities","getQueryEntities","args","LOG_2","intersectBits","a","b","getSize","field","indexOf","bit","TypeError","toggle","i","RangeError","create","Uint32Array","Math","ceil","clone","result","set","cloneWithToggle","key","sources","res","visited","source","add","fromObjects","objs","obj","getPopulationCount","val","popcnt","getPosition","index","position","isSet","idx","Archetype","bitfield","candidateCache","entered","entities","exited","isDirty","bitfield.fromObjects","Map","id","toString","isEmpty","addEntity","entity","bitfield.clone","isCandidate","cached","get","status","checkCandidacy","refresh","clear","removeEntity","delete","replacer","space","JSON","stringify","map","inst","join","ArchetypeManager","archetypeMap","entityArchetypes","rootArchetype","capacity","from","getArchetype","resetArchetype","refreshArchetypes","queries","archetype","archetypes","setArchetype","Error","updateArchetype","previousArchetype","bitfield.cloneWithToggle","bitfield.getSize","nextArchetype","bitfield.create","fill","nextAvailableIdx","acquire","bitpool","getLowestSetBit","release","bitfield.getPosition","storageProxy","storage","changed","entityId","proxy","getEntity","setEntity","defineProperty","refreshComponentInstance","instance","createComponentInstance","owners","configurable","enumerable","writable","count","bitfield.getPopulationCount","keys","forEach","k","sparseFacade","dense","sparse","available","bitpool.create","Proxy","_target","bitpool.acquire","deleteProperty","bitpool.release","ComponentBuffer","ArrayBuffer","partitions","super","isFinite","getTotalStorageSize","buffer","byteOffset","requiredSize","partition","typedArrayConstructor","initialValue","partitionComponentBuffer","bitfield.isSet","bitfield.toggle","prop","ComponentManager","componentMap","instantiate","addComponentsToEntity","instances","getInstances","filter","properties","removeComponentsFromEntity","getBuffer","slice","getInstance","setBuffer","byteLength","view","Uint8Array","refreshComponents","export","_flattenEntered","_flattenEntities","_flattenExited","refreshQuery","QueryManager","entityCache","queryMap","componentManager","getComponentsFromQuery","getQueryInstance","getEnteredFromQuery","getEntitiesFromQuery","getExitedFromQuery","registerQuery","getComponentInstances","arr","_allInstances","and","_anyInstances","or","_noneInstances","not","fromEntries","c","assign","target","createQueryInstance","refreshQueries","World","archetypeManager","queryManager","version","validateWorldSpec","residents","vacancies","cb","isValidEntity","createEntity","destroyEntity","getChangedFromComponents","changedSets","getChangedFromQuery","getComponentInstance","getEntityProperties","props","getQueryEntered","getQueryExited","hasComponent","hasComponents","isEntityActive","load","data","remover","save"],"mappings":";;AAGO,MAMMA,EAAkBC,OAAOC,OACpC,IAAIC,IAAI,CAEN,UACA,YACA,QACA,MACA,SACA,KACA,QACA,cACA,OACA,SACA,QACA,SACA,OAEA,cACA,iBACA,gBACA,uBACA,YACA,iBACA,WACA,UACA,mBACA,mBACA,mBACA,mBACA,eAKSC,EAAqB,4BAGrBC,EAAcJ,OAAOC,OAAO,IAG5BI,EAAYC,OAAO,WAGnBC,EAAWD,OAAO,UC/CzB,SAAUE,EAASC,GACvB,OAAQC,MAAMD,IAAMA,GAAK,GAAKA,GDAN,UCC1B,CAGM,SAAUE,EAAcF,GAC5B,OAAOD,EAASC,IAAMA,EAAI,CAC5B,CAoCM,SAAUG,EAAwBC,GACtC,OAAOC,QAA0B,mBAAXD,GAAyBb,OAAOe,UAAUC,eAAeC,KAAKJ,EAAQ,qBAC9F,CAGM,SAAUK,EAAYC,GAC1B,OAAOL,QACU,iBAARK,GAAoBA,EAAIC,OAAS,IAAMrB,EAAgBsB,IAAIF,IAAQhB,EAAmBmB,KAAKH,GAEtG,CAGM,SAAUI,EAASV,GACvB,OAAOC,QAA0B,iBAAXD,IAAwBW,MAAMC,QAAQZ,GAC9D,CCzBA,SAASa,GAAsBC,EAAMC,IACnC,OAAOV,EAAYS,IAXrB,SAAwBC,GACtB,GAAIJ,MAAMC,QAAQG,GAAQ,CAExB,MAAOC,EAAKpB,GAAKmB,EACjB,OAAQlB,MAAMD,IAAMG,EAAwBiB,EAC7C,CACD,OAAOjB,EAAwBgB,EACjC,CAI8BE,CAAeF,EAC7C,CAGM,SAAUG,EAAmCC,GACjD,IACE,QAAeC,IAAXD,EAAsB,OAAO,EACjC,GAAe,OAAXA,EAAiB,OAAO,EAC5B,IAAKT,EAASS,GAAS,OAAO,EAC9B,MAAME,EAAUlC,OAAOkC,QAAQF,GAC/B,QAAKE,EAAQd,QACNc,EAAQC,MAAMT,EAGtB,CAFC,MAAOU,GACP,OAAO,CACR,CACH,CAMA,SAASC,EAAQC,EAAgBV,GAI/B,OAAQU,GAHKd,MAAMC,QAAQG,GACtBA,EAAM,GAAkBW,kBACxBX,EAAqBW,kBAE5B,OC9CaC,EAEFC,MAEAC,YAEAf,KAEAK,OAEAW,KAUTC,YAAYC,GACV,IAAKA,EAAM,MAAM,IAAIC,YAAY,uCACjC,MAAMJ,YAAEA,EAAc,KAAIf,KAAEA,EAAIK,OAAEA,EAAS,MAASa,EACpD,GAAIH,IAAgB/B,EAAc+B,GAAc,MAAM,IAAII,YAAY,0CACtE,IAAK5B,EAAYS,GAAO,MAAM,IAAImB,YAAY,yBAC9C,IAAKf,EAAcC,GAAS,MAAM,IAAIc,YAAY,2BAClDC,KAAKN,OAAST,EACde,KAAKL,YAAcA,GAAe,KAClCK,KAAKpB,KAAOA,EACZoB,KAAKf,OAASA,EAAShC,OAAOC,OAAO,IAAK+B,IAAY,KACtDe,KAAKJ,KAAOX,EDsBV,SAAmDA,GACvD,IACE,OAAKD,EAAcC,GACJ,OAAXA,EAAwB,EAErBhC,OAAOgD,OAAOhB,GAAQiB,OAAOZ,EAAS,GAHVa,OAAOC,GAM3C,CAFC,MAAOf,GACP,OAAOc,OAAOC,GACf,CACH,CC/ByBC,CAAoBpB,GAAU,EACnDhC,OAAOC,OAAO8C,KACf,ECnCH,SAASM,EAA0CC,GACjD,OAAOA,aAAqBd,CAC9B,OAEae,EAEFC,IAEAC,IAEAC,KAaTd,YAAYC,GACV,IAAKA,EAAM,MAAM,IAAIC,YAAY,2CACjC,MAAMU,IAAEA,EAAMpD,EAAWqD,IAAEA,EAAMrD,EAAWsD,KAAEA,EAAOtD,GAAgByC,EACrE,IAAK,IAAIW,KAAQC,KAAQC,GAAMvB,MAAMkB,GACnC,MAAM,IAAIP,YAAY,0CAExBC,KAAKS,IAAMxD,OAAOC,OAAO,IAAI,IAAIC,IAAIsD,KACrCT,KAAKU,IAAMzD,OAAOC,OAAO,IAAI,IAAIC,IAAIuD,KACrCV,KAAKW,KAAO1D,OAAOC,OAAO,IAAI,IAAIC,IAAIwD,KACtC1D,OAAOC,OAAO8C,KACf,QCrBUY,EAKXC,OAEAC,MASAjB,YAAYC,GACV,MAAMe,OAAEA,EAAMC,MAAEA,GAAUhB,EAC1BE,KAAKa,OAASA,EACdb,KAAKc,MAAQA,CACd,CAODC,KAAKC,GACH,MAAMC,EAAaD,EAAME,mBAAmBlB,KAAKc,OAC3CK,EAAcH,EAAMI,iBAAiBpB,KAAKc,OAKhD,MAAO,IAAIO,IAAYrB,KAAKa,OAAOI,EAAYE,OAAkBE,EAClE,EC3DI,MAMMC,EAAgCrE,OAAOC,OAAO,CACzD,EAAG,EACH,EAAG,EACH,EAAG,EACH,EAAG,EACH,GAAI,EACJ,GAAI,EACJ,GAAI,EACJ,IAAK,EACL,IAAK,EACL,IAAK,EACL,KAAM,GACN,KAAM,GACN,KAAM,GACN,KAAM,GACN,MAAO,GACP,MAAO,GACP,MAAO,GACP,OAAQ,GACR,OAAQ,GACR,OAAQ,GACR,QAAS,GACT,QAAS,GACT,QAAS,GACT,QAAS,GACT,SAAU,GACV,SAAU,GACV,SAAU,GACV,UAAW,GACX,UAAW,GACX,UAAW,GACX,WAAY,GACZ,WAAY,GACZ,EAAE,YAAa,KCtBJqE,EAAgB,CAACC,EAAI,EAAGC,EAAI,IAAcD,EAAIC,ECP9CC,EAAWC,GAAoBA,EAAMtD,QAAU,EAK/CuD,EAAWC,IACtB,GAAIlE,MAAMkE,GAAM,MAAM,IAAIC,UAAU,oCAAoCD,MACxE,OAAIA,EAAM,GFdY,EEefA,IAAQ,CAAC,EAOLE,EAAS,CAACJ,EAAiBE,KACtC,MAAMG,EAAIJ,EAAQC,GAClB,IFxBsB,IEwBlBG,EAAgB,MAAM,IAAIC,WAAW,OAAOJ,qCAChD,MAAMhD,EAAQ,GAAMgD,EF5BM,GE4BAG,EAE1B,OADAL,EAAMK,IAAMnD,KACF8C,EAAMK,GAAO,GAAKnD,EAAO,EAOxBqD,EAAUtC,GACd,IAAIuC,YAAYC,KAAKC,KAAKzC,EFtCP,KE6Cf0C,EAASX,IACpB,MAAM/B,EAAO8B,EAAQC,GACfY,EAASL,EAAOtC,GAEtB,OADA2C,EAAOC,IAAIb,GACJY,CAAM,EAMFE,EAAkB,CAAId,EAAiBe,EAAcC,KAChE,MAAMC,EAAMN,EAAMX,GACZkB,EAAuB,IAAI1F,IACjC,IAAK,MAAM2F,KAAUH,EAAS,CAC5B,MAAM9D,EAAQiE,EAAOJ,GACjBG,EAAQvE,IAAIO,KAChBkD,EAAOa,EAAK/D,GACZgE,EAAQE,IAAIlE,GACb,CACD,OAAO+D,CAAG,EAaCI,EAAc,CAAIpD,EAAc8C,EAAcO,KACzD,MAAML,EAAMV,EAAOtC,GACbiD,EAAuB,IAAI1F,IACjC,IAAK,MAAM+F,KAAOD,EAAM,CACtB,MAAMpE,EAAQqE,EAAIR,GACdG,EAAQvE,IAAIO,KAChBkD,EAAOa,EAAK/D,GACZgE,EAAQE,IAAIlE,GACb,CACD,OAAO+D,CAAG,EAMCO,EAAsBxB,GACjCA,EAAMzB,QAAO,CAAC0C,EAAKQ,IACZA,EACER,EDxFuB,CAAC/D,IACjC,MAAM2C,EAAI3C,GAAUA,GAAS,EAAK,YAC5B4C,GAAS,UAAJD,IAAoBA,GAAK,EAAK,WACzC,OAAuC,UAA7BC,GAAKA,GAAK,GAAM,YAA2B,EAAE,ECqFxC4B,CAAOD,GADHR,GAEhB,GAKQU,EAAezB,IAAsD,CAChF0B,MAAO3B,EAAQC,GACf2B,SAAgB,GAAN3B,IAMC4B,EAAQ,CAAC9B,EAAiBE,KACrC,MAAM6B,EAAM9B,EAAQC,GACpB,IF5GsB,IE4GlB6B,EAAkB,MAAM,IAAIzB,WAAW,OAAOJ,qCAClD,SAAUF,EAAM+B,GAAS,GAAM7B,EFhHL,GEgHW6B,EAAqB,uKC3G/CC,EAEFC,SAEAC,eAEA5C,WAEA6C,QAEAC,SAEAC,OAETC,QAEApE,YAAYD,EAAcqB,EAAsCU,GAC9D3B,KAAK4D,SAAWjC,GAASuC,EAAqBtE,EAAM,KAAMqB,GAC1DjB,KAAK6D,eAAiB,IAAIM,IAC1BnE,KAAKiB,WAAaA,EAClBjB,KAAK8D,QAAU,IAAI3G,IACnB6C,KAAK+D,SAAW,IAAI5G,IACpB6C,KAAKgE,OAAS,IAAI7G,IAClB6C,KAAKiE,SAAU,CAChB,CAGGG,SACF,OAAOpE,KAAK4D,SAASS,UACtB,CAGGC,cACF,OAA8B,IAAvBtE,KAAK+D,SAASnE,IACtB,CAGGA,WACF,OAAOI,KAAK+D,SAASnE,IACtB,CAGD2E,UAAUC,GAIR,OAHAxE,KAAK+D,SAAShB,IAAIyB,GAClBxE,KAAK8D,QAAQf,IAAIyB,GACjBxE,KAAKiE,SAAU,EACRjE,IACR,CAGDsC,QACE,OAAO,IAAIqB,EAAU3D,KAAK4D,SAASvF,OAAQ2B,KAAKiB,WAAYwD,EAAezE,KAAK4D,UACjF,CAODc,YAAY5D,GACV,MAAM6D,EAAS3E,KAAK6D,eAAee,IAAI9D,GACvC,QAAe5B,IAAXyF,EAAsB,OAAOA,EACjC,MAAME,EAAS7E,KAAK4D,SAASxE,MAAM0B,EAAMgE,gBAEzC,OADA9E,KAAK6D,eAAerB,IAAI1B,EAAO+D,GACxBA,CACR,CAGDE,UAIE,OAHA/E,KAAK8D,QAAQkB,QACbhF,KAAKgE,OAAOgB,QACZhF,KAAKiE,SAAU,EACRjE,IACR,CAGDiF,aAAaT,GAIX,OAHAxE,KAAK+D,SAASmB,OAAOV,GACrBxE,KAAKgE,OAAOjB,IAAIyB,GAChBxE,KAAKiE,SAAU,EACRjE,IACR,CAGDqE,SAASc,EAAwDC,GAC/D,OAAOC,KAAKC,UACV,CACE1B,SAAU5D,KAAK4D,SAASS,WACxBpD,WAAYjB,KAAKiB,WAAWsE,KAAKC,GAASA,EAAKpB,KAAIqB,KAAK,KACxD1B,SAAU,IAAI/D,KAAK+D,SAAS9D,UAAUwF,KAAK,MAE7CN,EACAC,EAEH,QCvFUM,EAEXC,aAAuC,IAAIxB,IAE3CyB,iBAEAC,cAEAhG,YAAYC,GACV,MAAMgG,SAAEA,EAAQ7E,WAAEA,GAAenB,EACjCE,KAAK6F,cAAgB,IAAIlC,EAAU1C,EAAW5C,OAAQ,IACtD2B,KAAK2F,aAAe,IAAIxB,IACxBnE,KAAK2F,aAAanD,IAAIxC,KAAK6F,cAAczB,GAAIpE,KAAK6F,eAClD7F,KAAK4F,iBAAmBnH,MAAMsH,KAAK,CAAE1H,OAAQyH,IAAY,CAACzG,EAAG2C,IAAMhC,KAAK6F,cAActB,UAAUvC,IACjG,CAGDgE,aAAaxB,GACX,OAAOxE,KAAK4F,iBAAiBpB,EAC9B,CAGDyB,eAAezB,GACb,OAAIxE,KAAK4F,iBAAiBpB,KAAYxE,KAAK6F,gBAC3C7F,KAAK4F,iBAAiBpB,IAASS,aAAaT,GAC5CxE,KAAK4F,iBAAiBpB,GAAUxE,KAAK6F,cAActB,UAAUC,IAFIxE,IAIlE,CAGDkG,kBAAkBC,GAEhB,IAAK,MAAMC,KAAapG,KAAK2F,aAAa1F,SAAU,CAClD,IAAKmG,EAAU9B,QACb,IAAK,MAAMkB,KAAQW,EAAQlG,UACpBuF,EAAKa,WAAW/H,IAAI8H,IAAcA,EAAU1B,YAAYc,KAC3DA,EAAKvB,SAAU,EACfuB,EAAKa,WAAWtD,IAAIqD,IAI1BA,EAAUrB,SACX,CACD,OAAO/E,IACR,CAGDsG,aAAa9B,EAAgB4B,GAC3B,IAAKpG,KAAK2F,aAAarH,IAAI8H,EAAUhC,IAAK,MAAM,IAAImC,MAAM,sBAC1D,OAAIvG,KAAK4F,iBAAiBpB,KAAY4B,IACtCpG,KAAK4F,iBAAiBpB,IAASS,aAAaT,GAC5CxE,KAAK4F,iBAAiBpB,GAAU4B,EAAU7B,UAAUC,IAFIxE,IAIzD,CAQDwG,gBAAgBhC,EAAgBvD,GAE9B,MAAMwF,EAAoBzG,KAAK4F,iBAAiBpB,GAChDiC,GAAmBxB,aAAaT,GAChC,MAAM7C,EAAQ8E,GAAmB7C,SAC7B8C,EAAyBD,EAAkB7C,SAAU,KAAM3C,GAC3DiD,EAAqByC,EAAiB3G,KAAK6F,cAAcjC,UAAW,KAAM3C,GACxEmD,EAAKzC,EAAM0C,WACjB,IAAIuC,EAAgB5G,KAAK2F,aAAaf,IAAIR,GAM1C,OALKwC,IACHA,EAAgB,IAAIjD,EAAUgD,EAAiB3G,KAAK6F,cAAcjC,UAAW3C,EAAYU,GACzF3B,KAAK2F,aAAanD,IAAI4B,EAAIwC,IAE5B5G,KAAK4F,iBAAiBpB,GAAUoC,EAAcrC,UAAUC,GACjDoC,CACR,ECzEI,MAAM1E,EAAUtC,IACrB,MAAM+B,EAAQkF,EAAgBjH,GAE9B,OADA+B,EAAMmF,KAAK,YACJ,CACLnF,QACAoF,iBAAkB,EAClBnH,OACD,EAkBUoH,EAAWC,IACtB,MAAMF,iBAAEA,GAAqBE,EAC7B,KAAMF,EAAkB,OLvCF,EKwCtB,MAAMxD,EAAQ0D,EAAQtF,MAAMoF,GACtBvD,EJ7B+ClC,EAFxB,CAACzC,GAAkBA,GAASA,EAEEqI,CI6BrB3D,MLzChB,EK0CtB,GAAIC,GAAYyD,EAAQrH,KAAM,OL1CR,EK4CtB,GADAqH,EAAQtF,MAAMoF,MAAuB,GAAKvD,GACF,IAApCyD,EAAQtF,MAAMoF,GAAyB,CACzCE,EAAQF,kBL7CY,EK8CpB,IAAK,IAAI/E,EAAI,EAAGA,EAAIiF,EAAQtF,MAAMtD,OAAQ2D,IACxC,GAAyB,IAArBiF,EAAQtF,MAAMK,GAAU,CAC1BiF,EAAQF,iBAAmB/E,EAC3B,KACD,CAEJ,CACD,OAAQ+E,GAAoB,GAAKvD,CAAQ,EAS9B2D,EAAU,CAACF,EAAkBpI,KACxC,MAAM0E,MAAEA,EAAKC,SAAEA,GAAa4D,EAAqBvI,GACjD,OLhEsB,IKgElB0E,GAAsBC,GAAYyD,EAAQrH,OAC9CqH,EAAQtF,MAAM4B,IAAU,GAAKC,EAC7ByD,EAAQF,iBAAmBxD,GAFgC0D,CAG7C,EC5CA,SAAAI,EAAkCC,EAA2BC,GAC3E,IAAKD,EAAS,MAAM,IAAIvH,YAAY,mDACpC,IAAKwH,EAAS,MAAM,IAAIxH,YAAY,iCAGpC,IAAIyH,EAAmB,EAGvB,MAAMC,EAAQ,CACZC,UAAS,IACAF,EAETG,UAAUnD,GACR,GAAI7G,MAAM6G,IAAWA,EAAS,EAAG,MAAM,IAAI1C,UAAU,4CAErD,OADA0F,EAAWhD,EACJgD,CACR,GAIH,IAAK,MAAM9E,KAAO4E,EAChBrK,OAAO2K,eAAeH,EAAO/E,EAAK,CAEhCkC,IAAK,IAAM0C,EAAQ5E,GAAgB8E,GAEnChF,IAAM3D,IACAyI,EAAQ5E,GAAgB8E,KAAc3I,IACxCyI,EAAQ5E,GAAgB8E,GAAY3I,EACpC0I,EAAQxE,IAAIyE,GACb,IAKP,OAAOvK,OAAOC,OAAOuK,EACvB,CCnBM,SAAUI,EAA8CC,GAE5D,OADAA,EAASxK,GAAW0H,QACb8C,CACT,CAUM,SAAUC,EACdjI,GAEA,MAAMgG,SAAEA,EAAQvF,UAAEA,EAAS6D,GAAEA,EAAEkD,QAAEA,GAAYxH,EAC7C,IAAKlC,EAAckI,GAAW,MAAM,IAAI/F,YAAY,iCACpD,IAAKQ,EAAW,MAAM,IAAIgG,MAAM,kDAChC,IAAK9I,EAAS2G,GAAK,MAAM,IAAIrE,YAAY,4BACzC,GAAIuH,IAAY9I,EAAS8I,GAAU,MAAM,IAAIxF,UAAU,mCAEvD,MAAMyF,EAAuB,IAAIpK,IAC3B6K,EAAmBnB,EAAgBf,GAEnCgC,EAAW7K,OAAOiF,OAAO3B,EAAW,CACxCjD,CAACA,GAAY,CACXuB,MAAO0I,EACPU,cAAc,EACdC,YAAY,EACZC,UAAU,GAEZ3K,CAACA,GAAW,CACVqB,MAAOmJ,EACPC,cAAc,EACdC,YAAY,EACZC,UAAU,GAEZZ,QAAS,CACP3C,IAAG,IACM2C,EAAQtH,UAGnBmI,MAAO,CACLxD,IAAG,IACMyD,EAA4BL,IAGvC5D,GAAI,CACFvF,MAAOuF,EACP6D,cAAc,EACdC,YAAY,EACZC,UAAU,KAqBd,OAjBIb,IAEFrK,OAAO2K,eAAeE,EAAU,QAAS,CACvCjJ,MAAOwI,EAAaC,EAASC,GAC7BU,cAAc,EACdC,YAAY,EACZC,UAAU,IAIZlL,OAAOqL,KAAKhB,GAASiB,SAASC,IAC5BvL,OAAO2K,eAAeE,EAAUU,EAAG,CACjC3J,MAAOyI,EAAQkB,IACf,KAICvL,OAAOC,OAAO4K,EACvB,CCvGM,SAAUW,EAAmCC,GAEjD,MAAMC,EAAS,IAAIxE,IAGbyE,EAAYC,EAAeH,EAAMrK,QAwBvC,OAAO,IAAIyK,MAAMJ,EAAO,CACtB9D,IAAK,CAACmE,EAAYrG,KAAyBkC,OAtBhCJ,EAsBoC9B,EAtBjBgG,EAAMC,EAAO/D,IAAIJ,KAAY,GAAjD,IAACA,CAsB6D,EACxEhC,IAAK,CAACuG,EAAYrG,EAAsB7D,IApB9B,EAAC2F,EAAgB3F,KAC3B,MAAM6E,EAAMiF,EAAO/D,IAAIJ,IAAWwE,EAAgBJ,GAClD,YAAY1J,IAARwE,IACJgF,EAAMhF,GAAO7E,EACb8J,EAAOnG,IAAIgC,EAAQd,IACZ,EAAI,EAe6ClB,CAAIE,EAA0B7D,GACtFoK,eAAgB,CAACF,EAAYrG,IAZR,CAAC8B,IACtB,MAAMd,EAAMiF,EAAO/D,IAAIJ,GACvB,YAAYtF,IAARwE,IACJgF,EAAMhF,GAAO,EACbiF,EAAOzD,OAAOV,GACd0E,EAAgBN,EAAWlF,IACpB,EAAI,EAM2CuF,CAAevG,IAEzE,CC8DM,MAAOyG,UAAwBC,YAE1BtD,SAGAuD,WAAsD,IAAIlF,IAQnEtE,YAAYC,GACV,MAAMgG,SAAEA,EAAQ7E,WAAEA,GAAenB,EACjCwJ,MAxFY,SAAoBxD,EAAkB7E,GACpD,OAAOA,EAAWf,QAAO,CAAsBX,EAAegB,KAC5D,MAAMX,KAAEA,GAASW,EACjB,OAAKX,IAAS2J,SAAS3J,IAASA,EAAO,EAAUL,EAC1CA,EAAQK,EAAOkG,CAAQ,GAC7B,EACL,CAkFU0D,CAAoB1D,EAAU7E,IACpCjB,KAAK8F,SAAWA,EAChB9F,KAAKqJ,oBA1EPI,EACA3D,EACA7E,GAEA,MAAMoI,EAAa,IAAIlF,IACvB,IAAIuF,EAAa,EACjB,IAAK,MAAMnJ,KAAaU,EAAY,CAClC,MAAMtB,YAAEA,EAAWV,OAAEA,GAAWsB,EAEhC,IAAKtB,EAAQ,OAAOoK,EAEpB,MAAMM,EAAehK,GAAemG,EAE9B8D,EAAY,CAAA,EAElB,IAAK,MAAOlH,EAAK7D,KAAU5B,OAAOkC,QAAQF,GAAS,CAEjD,IAAI4K,EAAwBhL,EACxBiL,EAAe,EACfrL,MAAMC,QAAQG,MAASgL,EAAuBC,GAAgBjL,GAElE,MAAM6J,EAAQ,IAAImB,EAAsBJ,EAAQC,EAAYC,GAC5DC,EAAUlH,GAAuB,OAAhB/C,EAAuB+I,EAAQD,EAAaC,GAC7DkB,EAAUlH,IAAMoE,KAAKgD,GAErBJ,GAAcG,EAAsBrK,kBAAoBmK,CACzD,CACDN,EAAW7G,IAAIjC,EAAWqJ,EAC3B,CACD,OAAOP,CACT,CA4CsBU,CAAyB/J,KAAM8F,EAAU7E,EAC5D,ECrEa,SAAAgE,EAAkC6C,EAAgCtD,GAChF,MAAM7E,YAAEA,EAAWV,OAAEA,GAAW6I,EAChC,OAAKkC,EAAelC,EAAStK,GAAWgH,IACxCyF,EAAgBnC,EAAStK,GAAWgH,GAChCvF,GAEFhC,OAAOkC,QAAQF,GAAQsJ,SAAQ,EAAE7F,EAAKwH,MACpC,MAAM5C,EAAUQ,EAASpF,GACrB4E,IACE3H,SACK2H,EAAQ9C,GAEf8C,EAAQ9C,GAAU/F,MAAMC,QAAQwL,GAASA,EAAK,GAAgB,EAEjE,IAGEpC,GAfiD,IAgB1D,OAEaqC,EACFV,OACAW,aAETvK,YAAYC,GACV,MAAMgG,SAAEA,EAAQ7E,WAAEA,GAAenB,EACjCE,KAAKyJ,OAAS,IAAIN,EAAgB,CAAErD,WAAU7E,eAC9CjB,KAAKoK,aAlET,SAAqBX,EAAyB3D,EAAkB7E,GAC9D,OAAO,IAAIkD,IACTlD,EAAWsE,KAAI,CAAChF,EAAW6D,IAAO,CAChC7D,EACAwH,EAAwB,CACtBjC,WACAvF,YACA6D,KACAkD,QAASmC,EAAOJ,WAAWzE,IAAIrE,QAIvC,CAsDwB8J,CAAYrK,KAAKyJ,OAAQ3D,EAAU7E,EACxD,CAEDqJ,sBACErJ,GAEA,MAAMsJ,EAAYvK,KAAKwK,aAAavJ,GAAYwJ,OAAO1M,SACvD,GAAIwM,EAAUlM,SAAW4C,EAAW5C,OAAQ,MAAM,IAAIkI,MAAM,qDAC5D,MAAO,CAAC/B,EAAgBkG,IACfH,EACJhF,KAAKuC,YA5DZA,EACAtD,EACAkG,GAEA,MAAM/K,YAAEA,EAAWf,KAAEA,EAAIK,OAAEA,GAAW6I,EACtC,GAAInI,GAAemI,EAASM,OAASzI,EACnC,MAAM,IAAI4G,MAAM,cAAc3H,2BAEhC,OAAIoL,EAAelC,EAAStK,GAAWgH,GAAgB,MACvDyF,EAAgBnC,EAAStK,GAAWgH,GAEhCvF,GAEFhC,OAAOkC,QAAQF,GAAQsJ,SAAQ,EAAE7F,EAAK7D,MACpCiJ,EAASpF,GAAgB8B,GAAUkG,EAC9BA,EAAW9L,GAAyB8D,IAAoB7D,EAA0C,IAAM,EACxGA,EAA0C,IAAM,CAAC,IAGnDiJ,EACT,CAwC2BvD,CAAUuD,EAAUtD,EAAQkG,KAC9CD,OAAO1M,QAEb,CAED4M,2BAA2B1J,GACzB,MAAMsJ,EAAYvK,KAAKwK,aAAavJ,GAAYwJ,OAAO1M,SACvD,GAAIwM,EAAUlM,SAAW4C,EAAW5C,OAAQ,MAAM,IAAIkI,MAAM,qDAC5D,OAAQ/B,GACC+F,EAAUhF,KAAKuC,GAAa7C,EAAa6C,EAAUtD,KAASiG,OAAO1M,QAE7E,CAED6M,YACE,OAAO5K,KAAKyJ,OAAOoB,MAAM,EAC1B,CAEDC,YAAiCvK,GAC/B,OAAOP,KAAKoK,aAAaxF,IAAIrE,EAC9B,CAEDiK,aAAavJ,GAEX,OAAOA,EAAWsE,IAAIvF,KAAK8K,YAAa9K,KACzC,CAED+K,UAAUjI,GACR,GAAIA,EAAOkI,aAAehL,KAAKyJ,OAAOuB,WACpC,MAAM,IAAIzE,MAAM,mCAElB,MAAM0E,EAAO,IAAIC,WAAWpI,GAG5B,OAFe,IAAIoI,WAAWlL,KAAKyJ,QAC5BjH,IAAIyI,GACJjL,IACR,CAEDmL,oBAEE,OADAnL,KAAKoK,aAAa7B,QAAQV,GACnB7H,IACR,CAEDoL,SACE,MAAO,CACL3B,OAAQzJ,KAAKyJ,OACbxI,WAAY,IAAIjB,KAAKoK,aAAanK,UAErC,EClIH,SAASoL,GAAmCvH,QAAEA,IAE5CA,EAAQyE,QAAQvI,KAAK+C,IAAK/C,KAC5B,CAEA,SAASsL,GAAoCvH,SAAEA,IAE7CA,EAASwE,QAAQvI,KAAK+C,IAAK/C,KAC7B,CAEA,SAASuL,GAAkCvH,OAAEA,IAE3CA,EAAOuE,QAAQvI,KAAK+C,IAAK/C,KAC3B,CAEA,SAASwL,EAAa1K,GACpBA,EAAMmD,SAAU,CAClB,OAMawH,EAEXrB,aAEAsB,YAEAC,SAWA9L,YAAYC,GACV,MAAM8L,iBAAEA,GAAqB9L,EAC7BE,KAAKoK,aAAewB,EAAiBxB,aACrCpK,KAAK0L,YAAc,IAAIvH,IACvBnE,KAAK2L,SAAW,IAAIxH,GACrB,CAGD0H,uBAAuB/K,GACrB,OAAOd,KAAK8L,iBAAiBhL,GAAOG,UACrC,CAGD8K,oBAAoBjL,GAClB,MAAM8B,EAAmB,IAAIzF,IACvB2K,EAAW9H,KAAK8L,iBAAiBhL,GACvC,MAAO,KACL8B,EAAIoC,QACJ8C,EAASzB,WAAWkC,QAAQ8C,EAAiBzI,GACtCA,EAAI3C,SAEd,CAGD+L,qBAAqBlL,GACnB,MAAMgH,EAAW9H,KAAK8L,iBAAiBhL,GACjC6D,EAAS3E,KAAK0L,YAAY9G,IAAIkD,IAAa9H,KAAK0L,YAAYlJ,IAAIsF,EAAU,IAAI3K,KAAOyH,IAAIkD,GAC/F,MAAO,KACL,MAAMzB,WAAEA,EAAUpC,QAAEA,GAAY6D,EAgBhC,OAfgB,IAAZ7D,GAAqBU,EAAO/E,KAM9ByG,EAAWkC,SAASnC,KACQ,IAAtBA,EAAUnC,UAEZmC,EAAUtC,QAAQyE,QAAQ5D,EAAO5B,IAAK4B,GAEtCyB,EAAUpC,OAAOuE,QAAQ5D,EAAOO,OAAQP,GACzC,KAVHA,EAAOK,QACPqB,EAAWkC,QAAQ+C,EAAkB3G,IAYhCA,EAAO1E,QAAQ,CAEzB,CAGDgM,mBAAmBnL,GACjB,MAAM8B,EAAmB,IAAIzF,IACvB2K,EAAW9H,KAAK8L,iBAAiBhL,GACvC,MAAO,KACL8B,EAAIoC,QACJ8C,EAASzB,WAAWkC,QAAQgD,EAAgB3I,GACrCA,EAAI3C,SAEd,CAGD6L,iBAAiBhL,GACf,OAAOd,KAAK2L,SAAS/G,IAAI9D,IAAUd,KAAKkM,cAAcpL,EACvD,CAGDoL,cAAcpL,GACZ,KAAMA,aAAiBN,GAAQ,MAAM,IAAI+F,MAAM,gCAC/C,MAAM5B,EAAS3E,KAAK2L,SAAS/G,IAAI9D,GACjC,GAAI6D,EAAQ,OAAOA,EACnB,MAAMmD,ECtFJ,SAA8BhI,GAClC,MAAMsK,aAAEA,EAAYtJ,MAAEA,GAAUhB,GAC1BW,IAAEA,EAAGC,IAAEA,EAAGC,KAAEA,GAASG,EAErBqL,EAAwB,CAC5BC,EACA7L,EACAmD,KAEA,MAAM8B,EAAO4E,EAAaxF,IAAIrE,GAC9B,IAAKiF,EAAM,MAAM,IAAIe,MAAM,aAAahG,EAAU3B,mBAElD,OADAwN,EAAI1I,GAAO8B,EACJ4G,CAAG,EAGN/N,EAAS+L,EAAaxK,KAEtByM,EAAgB5L,EAAIP,OAAOiM,EAAuB,IAAI1N,MAAMgC,EAAIpC,SAChEiO,EAAMpI,EAAqB7F,EAAQ,KAAMgO,GAEzCE,EAAgB7L,EAAIR,OAAOiM,EAAuB,IAAI1N,MAAMiC,EAAIrC,SAChEmO,EAAKtI,EAAqB7F,EAAQ,KAAMkO,GAExCE,EAAiB9L,EAAKT,OAAOiM,EAAuB,IAAI1N,MAAMkC,EAAKtC,SACnEqO,EAAMxI,EAAqB7F,EAAQ,KAAMoO,GAGzCxL,EAAahE,OAAO0P,YAAY,IAAIN,KAAkBE,GAAehH,KAAKqH,GAAM,CAACA,EAAEhO,KAAMgO,MAEzFvG,EAA6B,IAAIlJ,IAUvC,OAAOF,OAAO4P,OAAO5P,OAAOiF,OAAOpB,GAAQ,CACzCmD,SAAS,EACToC,aACAiG,MACAxH,eAZqB,CAACgI,EAAgBpJ,KACf,IAAZ8I,EAAG9I,IAAcnC,EAAcuL,EAAQN,EAAG9I,IAAQ,OAEjDnC,EAAcuL,EAAQR,EAAI5I,MAAU4I,EAAI5I,KAET,IAApCnC,EAAcuL,EAAQJ,EAAIhJ,KAQjCzC,aACAyL,MACAF,MAEJ,CDsCqBO,CAAoB,CAAE3C,aAAcpK,KAAKoK,aAActJ,UAExE,OADAd,KAAK2L,SAASnJ,IAAI1B,EAAOgH,GAClBA,CACR,CAGDkF,iBAEE,OADAhN,KAAK2L,SAASpD,QAAQiD,GACfxL,IACR,CAEDoL,SACE,MAAO,CACLjF,QAAS,IAAInG,KAAK2L,SAAS1L,UAE9B,QE/EUgN,EACMC,iBACAtB,iBACAuB,aAGApJ,SAGR+B,SAGAsH,QnBpEY,SmB6ErBvN,YAAYC,GACV,MAAMgG,SAAEA,EAAQ7E,WAAEA,GAvCtB,SAA2BnB,GAEzB,IAAKA,IAAStB,EAASsB,GACrB,MAAM,IAAIC,YAAY,mDAExB,MAAM+F,SAAEA,EAAQ7E,WAAEA,GAAenB,EAEjC,IAAKlC,EAAckI,GACjB,MAAM,IAAI/F,YAAY,iCAGxB,IAAKtB,MAAMC,QAAQuC,KAAgBA,EAAW7B,OAAOwN,GAAM3P,OAAOe,UAAUC,eAAeC,KAAK0O,EAAG,UACjG,MAAM,IAAI9K,UAAU,mCAEtB,MAAO,IAAKhC,EAAMgG,SAAU1D,KAAKC,KAAKyD,GAAW7E,WAAY,IAAI,IAAI9D,IAAI8D,IAC3E,CAwBqCoM,CAAkBvN,GACnDE,KAAK8F,SAAWA,EAChB9F,KAAK+D,SAAW8E,EAAe/C,GAC/B9F,KAAKkN,iBAAmB,IAAIxH,EAAiB,CAAEI,WAAU7E,eACzDjB,KAAK4L,iBAAmB,IAAIzB,EAAiB,CAAErE,WAAU7E,eACzDjB,KAAKmN,aAAe,IAAI1B,EAAa,CAAEG,iBAAkB5L,KAAK4L,mBAC9D5L,KAAK+E,UACL9H,OAAOC,OAAO8C,KACf,CAGGsN,gBACF,MAAMxH,SAAEA,GAAa9F,MACf2B,MAAEA,GAAU3B,KAAK+D,UACjBZ,mBAAEA,EAAkBzB,QAAEA,GAAYkC,EACxC,OAAOkC,GAAY3C,EAAmBxB,IAAUD,EAAQC,GAASmE,GAClE,CAGGyH,gBACF,OAAOvN,KAAK8F,SAAW9F,KAAKsN,SAC7B,CAQDhD,yBAAyBrJ,GACvB,MAAMuM,EAAKxN,KAAK4L,iBAAiBtB,sBAAsBrJ,GACvD,MAAO,CAACuD,EAAgBkG,KACtB,IAAK1K,KAAKyN,cAAcjJ,GAAS,MAAM,IAAIzE,YAAY,UAAUyE,mBAEjE,OADAxE,KAAKkN,iBAAiB1G,gBAAgBhC,EAAQgJ,EAAGhJ,EAAQkG,IAClD1K,IAAI,CAEd,CAGD0N,eACE,GAAI1N,KAAKsN,WAAatN,KAAK8F,SAAU,OACrC,MAAMtB,EAASwE,EAAgBhJ,KAAK+D,UACpC,OAAIS,EAAS,OAAb,GACAxE,KAAKkN,iBAAiB5G,aAAa9B,EAAQxE,KAAKkN,iBAAiBrH,eAC1DrB,EACR,CAQDmJ,cAAcnJ,GACZ,IAAKxE,KAAKyN,cAAcjJ,GAAS,MAAM,IAAIzE,YAAY,UAAUyE,mBAMjE,OALAxE,KAAKkN,iBAAiBtH,iBAAiBpB,IAASvD,WAAWsH,SAAST,IAClE7C,EAAa6C,EAAUtD,EAAO,IAEhCxE,KAAKkN,iBAAiBjH,eAAezB,GACrC0E,EAAgBlJ,KAAK+D,SAAUS,GACxBxE,IACR,CAQD4N,4BAA4B3M,GAC1B,MAAMsJ,EAAYvK,KAAK4L,iBAAiBpB,aAAavJ,GAAYwJ,OAAO1M,SACxE,GAAIwM,EAAUlM,SAAW4C,EAAW5C,OAAQ,MAAM,IAAIkI,MAAM,kCAC5D,MAAMsH,EAAc5Q,OAAOgD,OAAOsK,GAAWhF,KAAKC,GAASA,EAAK+B,UAC1DxD,EAAW,IAAI5G,IACrB,MAAO,KACL4G,EAASiB,QACT,IAAK,MAAMuC,KAAWsG,EACpB,IAAK,MAAMrJ,KAAU+C,EACnBxD,EAAShB,IAAIyB,GAGjB,OAAOT,EAAS9D,QAAQ,CAE3B,CASD6N,oBAAoBhN,GAClB,MAAMG,WAAEA,GAAejB,KAAKmN,aAAarB,iBAAiBhL,GACpD+M,EAAc5Q,OAAOgD,OAAOgB,GAAYsE,KAAKC,GAASA,EAAK+B,UAC3DxD,EAAW,IAAI5G,IACrB,MAAO,KACL4G,EAASiB,QACT,IAAK,MAAMuC,KAAWsG,EACpB,IAAK,MAAMrJ,KAAU+C,EACnBxD,EAAShB,IAAIyB,GAGjB,OAAOT,EAAS9D,QAAQ,CAE3B,CAOD8N,qBAA0CxN,GACxC,OAAOP,KAAK4L,iBAAiBxB,aAAaxF,IAAIrE,EAC/C,CAOD4L,yBAAyBlL,GACvB,OAAOjB,KAAK4L,iBAAiBpB,aAAavJ,EAC3C,CAOD+M,oBAAoBxJ,GAClB,MAAM4B,EAAYpG,KAAKkN,iBAAiBlH,aAAaxB,GACrD,IAAK4B,EAAW,MAAO,GACvB,MAAMnF,WAAEA,GAAemF,EACvB,OAAOnJ,OAAO0P,YACZ1L,EAAWsE,KAA0BhF,IACnC,MAAM3B,KAAEA,EAAIK,OAAEA,GAAWsB,EACzB,IAAI0N,GAAkC,EAMtC,OALIhP,IACFgP,EAAQhR,OAAO0P,YACb1P,OAAOqL,KAAKrJ,GAAQsG,KAAK7C,GAAQ,CAACA,EAAgBnC,EAAUmC,KAAkB8B,QAG3E,CAAC5F,EAAMqP,EAAM,IAGzB,CAQD/M,mBAAmBJ,GACjB,OAAOd,KAAKmN,aAAatB,uBAAuB/K,EACjD,CAQDoN,gBAAgBpN,GACd,OAAOd,KAAKmN,aAAapB,oBAAoBjL,EAC9C,CAQDM,iBAAiBN,GACf,OAAOd,KAAKmN,aAAanB,qBAAqBlL,EAC/C,CAQDqN,eAAerN,GACb,OAAOd,KAAKmN,aAAalB,mBAAmBnL,EAC7C,CAUDsN,aAAkC7N,GAChC,MAAMuH,EAAW9H,KAAK4L,iBAAiBd,YAAYvK,GACnD,IAAKuH,EAAU,MAAM,IAAIvB,MAAM,gCAC/B,OAAQ/B,GAAmBwF,EAAelC,EAAStK,GAAWgH,EAC/D,CAUD6J,iBAAiBpN,GACf,MAAMsJ,EAAYvK,KAAK4L,iBAAiBpB,aAAavJ,GAAYwJ,OAAO1M,SACxE,GAAIwM,EAAUlM,SAAW4C,EAAW5C,OAAQ,MAAM,IAAIkI,MAAM,kCAC5D,OAAQ/B,GACC+F,EAAUhF,KAAKhF,GAAcyJ,EAAezJ,EAAU/C,GAAWgH,IAE3E,CAOD8J,eAAe9J,GACb,OAAKxE,KAAKyN,cAAcjJ,GACjBwF,EAAehK,KAAK+D,SAASpC,MAAO6C,GADH,IAEzC,CAGDiJ,cAAcjJ,GACZ,OAAO/G,EAAS+G,IAAWA,EAASmC,EAAiB3G,KAAK+D,SAASpC,MACpE,CAOD4M,KAAKC,GACH,MAAM/E,OAAEA,EAAM3D,SAAEA,EAAQsH,QAAEA,GAAYoB,EACtC,GAAIpB,IAAYpN,KAAKoN,QACnB,MAAM,IAAI7G,MAAM,oCAAoC6G,eAAqBpN,KAAKoN,kBAEhF,GAAItH,IAAa9F,KAAK8F,SACpB,MAAM,IAAIS,MAAM,+DAA+DT,MAIjF,OAFA9F,KAAK4L,iBAAiBb,UAAUtB,GAChCzJ,KAAK+E,UACE/E,IACR,CAGD+E,UAIE,OAHA/E,KAAKmN,aAAaH,iBAClBhN,KAAKkN,iBAAiBhH,kBAAkBlG,KAAKmN,aAAaxB,UAC1D3L,KAAK4L,iBAAiBT,oBACfnL,IACR,CAQD2K,8BAA8B1J,GAC5B,MAAMwN,EAAUzO,KAAK4L,iBAAiBjB,2BAA2B1J,GACjE,OAAQuD,IACN,IAAKxE,KAAKyN,cAAcjJ,GAAS,MAAM,IAAIzE,YAAY,UAAUyE,mBAEjE,OADAxE,KAAKkN,iBAAiB1G,gBAAgBhC,EAAQiK,EAAQjK,IAC/CxE,IAAI,CAEd,CAGD0O,OACE,OAAOzR,OAAOC,OAAO,CACnBuM,OAAQzJ,KAAK4L,iBAAiBhB,YAC9B9E,SAAU9F,KAAK8F,SACfsH,QAASpN,KAAKoN,SAEjB"}