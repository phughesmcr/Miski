/*! Miski v0.11.1. MIT license. (C) 2021-2023 the Miski authors. All rights reserved. **/
/*! @author P. Hughes<github@phugh.es>(https://www.phugh.es) **/
const e=Object.freeze(new Set(["changed","component","count","eid","entity","id","isTag","maxEntities","name","owners","proxy","schema","size","constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","prototype","toLocaleString","toString","valueOf","__defineGetter__","__defineSetter__","__lookupGetter__","__lookupGetter__","__proto__"])),t=/^(?![0-9])[a-zA-Z0-9$_]+$/,n=Object.freeze([]),r=Symbol("changed"),i=Symbol("owners");function s(e){return!isNaN(e)&&e>=0&&e<=4294967295}function o(e){return s(e)&&e>0}function a(e){return Boolean("function"==typeof e&&Object.prototype.hasOwnProperty.call(e,"BYTES_PER_ELEMENT"))}function c(n){return Boolean("string"==typeof n&&n.length>0&&!e.has(n)&&t.test(n))}function h(e){return Boolean("object"==typeof e&&!Array.isArray(e))}function u([e,t]){return c(e)&&function(e){if(Array.isArray(e)){const[t,n]=e;return!isNaN(n)&&a(t)}return a(e)}(t)}function y(e){try{if(void 0===e)return!1;if(null===e)return!0;if(!h(e))return!1;const t=Object.entries(e);return!!t.length&&t.every(u)}catch(e){return!1}}function p(e,t){return e+(Array.isArray(t)?t[0].BYTES_PER_ELEMENT:t.BYTES_PER_ELEMENT)}class f{isTag;maxEntities;name;schema;size;constructor(e){if(!e)throw new SyntaxError("A specification object is required.");const{maxEntities:t=null,name:n,schema:r=null}=e;if(t&&!o(t))throw new SyntaxError("spec.maxEntities must be a Uint32 > 0.");if(!c(n))throw new SyntaxError("spec.name is invalid.");if(!y(r))throw new SyntaxError("spec.schema is invalid.");this.isTag=!r,this.maxEntities=t??null,this.name=n,this.schema=r?Object.freeze({...r}):null,this.size=r?function(e){try{return y(e)?null===e?0:Object.values(e).reduce(p,0):Number.NaN}catch(e){return Number.NaN}}(r):0,Object.freeze(this)}}function l(e){return e instanceof f}class d{all;any;none;constructor(e){if(!e)throw new SyntaxError("Query specification object is required.");const{all:t=n,any:r=n,none:i=n}=e;if(![...t,...r,...i].every(l))throw new SyntaxError("Query specification object is invalid.");this.all=Object.freeze([...new Set(t)]),this.any=Object.freeze([...new Set(r)]),this.none=Object.freeze([...new Set(i)]),Object.freeze(this)}}class m{system;query;constructor(e){const{system:t,query:n}=e;this.system=t,this.query=n}init(e){const t=e.getQueryComponents(this.query),n=e.getQueryEntities(this.query);return(...e)=>this.system(t,n(),...e)}}const g=Object.freeze({1:0,2:1,4:2,8:3,16:4,32:5,64:6,128:7,256:8,512:9,1024:10,2048:11,4096:12,8192:13,16384:14,32768:15,65536:16,131072:17,262144:18,524288:19,1048576:20,2097152:21,4194304:22,8388608:23,16777216:24,33554432:25,67108864:26,134217728:27,268435456:28,536870912:29,1073741824:30,2147483648:31,[-2147483648]:31}),E=(e=0,t=0)=>e&t,w=e=>e.length<<5,b=e=>{if(isNaN(e))throw new TypeError(`Expected a number, found "${typeof e}"`);return e<0?-1:e>>>5},M=(e,t)=>{const n=b(t);if(-1===n)throw new RangeError(`Bit ${t} does not exist in the bitfield.`);const r=1<<t-32*n;return e[n]^=r,!!(e[n]&1<<r)},v=e=>new Uint32Array(Math.ceil(e/32)),A=e=>{const t=w(e),n=v(t);return n.set(e),n},x=(e,t,n)=>{const r=A(e),i=new Set;for(const e of n){const n=e[t];i.has(n)||(M(r,n),i.add(n))}return r},S=(e,t,n)=>{const r=v(e),i=new Set;for(const e of n){const n=e[t];i.has(n)||(M(r,n),i.add(n))}return r},j=e=>e.reduce(((e,t)=>t?e+(e=>{const t=e-(e>>1&1431655765),n=(858993459&t)+(t>>2&858993459);return 16843009*(n+(n>>4)&252645135)>>24})(t):e),0),O=e=>({index:b(e),position:31&e}),C=(e,t)=>{const n=b(t);if(-1===n)throw new RangeError(`Bit ${t} does not exist in the bitfield.`);return!!(e[n]&1<<t-32*n)};var _=Object.freeze({__proto__:null,clone:A,cloneWithToggle:x,create:v,fromObjects:S,getPopulationCount:j,getPosition:O,getSize:w,indexOf:b,isSet:C,toggle:M});class q{bitfield;candidateCache;components;entered;entities;exited;isDirty;constructor(e,t,n){this.bitfield=n??S(e,"id",t),this.candidateCache=new Map,this.components=t,this.entered=new Set,this.entities=new Set,this.exited=new Set,this.isDirty=!0}get id(){return this.bitfield.toString()}get isEmpty(){return 0===this.entities.size}get size(){return this.entities.size}addEntity(e){return this.entities.add(e),this.entered.add(e),this.isDirty=!0,this}clone(){return new q(this.bitfield.length,this.components,A(this.bitfield))}isCandidate(e){const t=this.candidateCache.get(e);if(void 0!==t)return t;const n=this.bitfield.every(e.checkCandidacy);return this.candidateCache.set(e,n),n}refresh(){return this.entered.clear(),this.exited.clear(),this.isDirty=!1,this}removeEntity(e){return this.entities.delete(e),this.exited.add(e),this.isDirty=!0,this}toString(e,t){return JSON.stringify({bitfield:this.bitfield.toString(),components:this.components.map((e=>e.id)).join(","),entities:[...this.entities.values()].join(",")},e,t)}}class z{archetypeMap=new Map;entityArchetypes;rootArchetype;constructor(e){const{capacity:t,components:n}=e;this.rootArchetype=new q(n.length,[]),this.archetypeMap=new Map,this.archetypeMap.set(this.rootArchetype.id,this.rootArchetype),this.entityArchetypes=Array.from({length:t},((e,t)=>this.rootArchetype.addEntity(t)))}getArchetype(e){return this.entityArchetypes[e]}resetArchetype(e){return this.entityArchetypes[e]===this.rootArchetype||(this.entityArchetypes[e]?.removeEntity(e),this.entityArchetypes[e]=this.rootArchetype.addEntity(e)),this}refreshArchetypes(e){for(const t of this.archetypeMap.values()){if(!t.isEmpty)for(const n of e.values())!n.archetypes.has(t)&&t.isCandidate(n)&&(n.isDirty=!0,n.archetypes.add(t));t.refresh()}return this}setArchetype(e,t){if(!this.archetypeMap.has(t.id))throw new Error("Invalid archetype.");return this.entityArchetypes[e]===t||(this.entityArchetypes[e]?.removeEntity(e),this.entityArchetypes[e]=t.addEntity(e)),this}updateArchetype(e,t){const n=this.entityArchetypes[e];n?.removeEntity(e);const r=n?.bitfield?x(n.bitfield,"id",t):S(w(this.rootArchetype.bitfield),"id",t),i=r.toString();let s=this.archetypeMap.get(i);return s||(s=new q(w(this.rootArchetype.bitfield),t,r),this.archetypeMap.set(i,s)),this.entityArchetypes[e]=s.addEntity(e),s}}const Q=e=>{const t=v(e);return t.fill(4294967295),{field:t,nextAvailableIdx:0,size:e}},I=e=>{const{nextAvailableIdx:t}=e;if(!~t)return-1;const n=e.field[t],r=g[(e=>e&-e)(n)]??-1;if(r>=e.size)return-1;if(e.field[t]&=~(1<<r),0===e.field[t]){e.nextAvailableIdx=-1;for(let t=0;t<e.field.length;t++)if(0!==e.field[t]){e.nextAvailableIdx=t;break}}return(t<<5)+r},B=(e,t)=>{const{index:n,position:r}=O(t);return-1===n||r>=e.size||(e.field[n]|=1<<r,e.nextAvailableIdx=n),e};function N(e,t){if(!e)throw new SyntaxError("Proxy can only be used on components, not tags.");if(!t)throw new SyntaxError("Proxy requires a changed set.");let n=0;const r={getEntity:()=>n,setEntity(e){if(isNaN(e)||e<0)throw new TypeError("Expected entity to be a positive number.");return n=e,n}};for(const i in e)Object.defineProperty(r,i,{get:()=>e[i][n],set:r=>{e[i][n]!==r&&(e[i][n]=r,t.add(n))}});return Object.freeze(r)}function T(e){return e[r].clear(),e}function P(e){const{capacity:t,component:n,id:a,storage:c}=e;if(!o(t))throw new SyntaxError("Capacity must be integer > 0.");if(!n)throw new Error("Component instantiation requires as component!");if(!s(a))throw new SyntaxError("Component ID is invalid.");if(c&&!h(c))throw new TypeError("Component storage is malformed.");const u=new Set,y=v(t),p=Object.create(n,{[r]:{value:u,configurable:!1,enumerable:!1,writable:!1},[i]:{value:y,configurable:!1,enumerable:!1,writable:!1},changed:{get:()=>u.values()},count:{get:()=>j(y)},id:{value:a,configurable:!1,enumerable:!0,writable:!1}});return c&&(Object.defineProperty(p,"proxy",{value:N(c,u),configurable:!1,enumerable:!0,writable:!1}),Object.keys(c).forEach((e=>{Object.defineProperty(p,e,{value:c[e]})}))),Object.freeze(p)}function F(e){const t=new Map,n=Q(e.length);return new Proxy(e,{get:(n,r)=>{return i=r,e[t.get(i)??-1];var i},set:(r,i,s)=>((r,i)=>{const s=t.get(r)??I(n);return void 0!==s&&(e[s]=i,t.set(r,s),!0)})(i,s),deleteProperty:(r,i)=>(r=>{const i=t.get(r);return void 0!==i&&(e[i]=0,t.delete(r),B(n,i),!0)})(i)})}class $ extends ArrayBuffer{capacity;partitions=new Map;constructor(e){const{capacity:t,components:n}=e;super(function(e,t){return t.reduce(((t,n)=>{const{size:r}=n;return!r||!isFinite(r)||r<0?t:t+r*e}),0)}(t,n)),this.capacity=t,this.partitions=function(e,t,n){const r=new Map;let i=0;for(const s of n){const{maxEntities:n,schema:o}=s;if(!o)return r;const a=n??t,c={};for(const[t,r]of Object.entries(o)){let s=r,o=0;Array.isArray(r)&&([s,o]=r);const h=new s(e,i,a);c[t]=null===n?h:F(h),c[t]?.fill(o),i+=s.BYTES_PER_ELEMENT*a}r.set(s,c)}return r}(this,t,n)}}function D(e,t){const{maxEntities:n,schema:r}=e;return C(e[i],t)?(M(e[i],t),r&&Object.entries(r).forEach((([r,i])=>{const s=e[r];s&&(n?delete s[t]:s[t]=Array.isArray(i)?i[1]:0)})),e):null}class L{buffer;componentMap;constructor(e){const{capacity:t,components:n}=e;this.buffer=new $({capacity:t,components:n}),this.componentMap=function(e,t,n){return new Map(n.map(((n,r)=>[n,P({capacity:t,component:n,id:r,storage:e.partitions.get(n)})])))}(this.buffer,t,n)}addComponentsToEntity(e){const t=this.getInstances(e).filter(Boolean);if(t.length!==e.length)throw new Error("Some components are not registered in this world!");return(e,n)=>t.map((t=>function(e,t,n){const{maxEntities:r,name:s,schema:o}=e;if(r&&e.count>=r)throw new Error(`Component "${s}".maxEntities reached.`);return C(e[i],t)?null:(M(e[i],t),o&&Object.entries(o).forEach((([r,i])=>{e[r][t]=n?n[s][r]??i[1]??0:i[1]??0})),e)}(t,e,n))).filter(Boolean)}removeComponentsFromEntity(e){const t=this.getInstances(e).filter(Boolean);if(t.length!==e.length)throw new Error("Some components are not registered in this world!");return e=>t.map((t=>D(t,e))).filter(Boolean)}getBuffer(){return this.buffer.slice(0)}getInstance(e){return this.componentMap.get(e)}getInstances(e){return e.map(this.getInstance,this)}setBuffer(e){if(e.byteLength!==this.buffer.byteLength)throw new Error("setBuffer: byteLength mismatch!");const t=new Uint8Array(e);return new Uint8Array(this.buffer).set(t),this}refreshComponents(){return this.componentMap.forEach(T),this}export(){return{buffer:this.buffer,components:[...this.componentMap.values()]}}}function k({entered:e}){e.forEach(this.add,this)}function R({entities:e}){e.forEach(this.add,this)}function V({exited:e}){e.forEach(this.add,this)}function U(e){e.isDirty=!1}class W{componentMap;entityCache;queryMap;constructor(e){const{componentManager:t}=e;this.componentMap=t.componentMap,this.entityCache=new Map,this.queryMap=new Map}getComponentsFromQuery(e){return this.getQueryInstance(e).components}getEnteredFromQuery(e){const t=new Set,n=this.getQueryInstance(e);return()=>(t.clear(),n.archetypes.forEach(k,t),t.values())}getEntitiesFromQuery(e){const t=this.getQueryInstance(e),n=this.entityCache.get(t)??this.entityCache.set(t,new Set).get(t);return()=>{const{archetypes:e,isDirty:r}=t;return!0!==r&&n.size?e.forEach((e=>{!0===e.isDirty&&(e.entered.forEach(n.add,n),e.exited.forEach(n.delete,n))})):(n.clear(),e.forEach(R,n)),n.values()}}getExitedFromQuery(e){const t=new Set,n=this.getQueryInstance(e);return()=>(t.clear(),n.archetypes.forEach(V,t),t.values())}getQueryInstance(e){return this.queryMap.get(e)??this.registerQuery(e)}registerQuery(e){if(!(e instanceof d))throw new Error("Object is not a valid query.");const t=this.queryMap.get(e);if(t)return t;const n=function(e){const{componentMap:t,query:n}=e,{all:r,any:i,none:s}=n,o=(e,n,r)=>{const i=t.get(n);if(!i)throw new Error(`Component ${n.name} not found.`);return e[r]=i,e},a=t.size,c=r.reduce(o,new Array(r.length)),h=S(a,"id",c),u=i.reduce(o,new Array(i.length)),y=S(a,"id",u),p=s.reduce(o,new Array(s.length)),f=S(a,"id",p),l=Object.fromEntries([...c,...u].map((e=>[e.name,e]))),d=new Set;return Object.assign(Object.create(n),{isDirty:!0,archetypes:d,and:h,checkCandidacy:(e,t)=>(0===y[t]||E(e,y[t])>0)&&(!(E(e,h[t])!==h[t])&&0===E(e,f[t])),components:l,not:f,or:y})}({componentMap:this.componentMap,query:e});return this.queryMap.set(e,n),n}refreshQueries(){return this.queryMap.forEach(U),this}export(){return{queries:[...this.queryMap.values()]}}}class Y{archetypeManager;componentManager;queryManager;entities;capacity;version="0.11.1";constructor(e){const{capacity:t,components:n}=function(e){if(!e||!h(e))throw new SyntaxError("World creation requires a specification object.");const{capacity:t,components:n}=e;if(!o(t))throw new SyntaxError("World: spec.capacity invalid.");if(!Array.isArray(n)||!n.every((e=>Object.prototype.hasOwnProperty.call(e,"name"))))throw new TypeError("World: spec.components invalid.");return{...e,capacity:Math.ceil(t),components:[...new Set(n)]}}(e);this.capacity=t,this.entities=Q(t),this.archetypeManager=new z({capacity:t,components:n}),this.componentManager=new L({capacity:t,components:n}),this.queryManager=new W({componentManager:this.componentManager}),this.refresh(),Object.freeze(this)}get residents(){const{capacity:e}=this,{field:t}=this.entities,{getPopulationCount:n,getSize:r}=_;return e-(n(t)-(r(t)-e))}get vacancies(){return this.capacity-this.residents}addComponentsToEntity(...e){const t=this.componentManager.addComponentsToEntity(e);return(e,n)=>{if(!this.isValidEntity(e))throw new SyntaxError(`Entity ${e} is not valid!`);return this.archetypeManager.updateArchetype(e,t(e,n)),this}}createEntity(){if(this.residents>=this.capacity)return;const e=I(this.entities);return e<0?void 0:(this.archetypeManager.setArchetype(e,this.archetypeManager.rootArchetype),e)}destroyEntity(e){if(!this.isValidEntity(e))throw new SyntaxError(`Entity ${e} is not valid!`);return this.archetypeManager.entityArchetypes[e]?.components.forEach((t=>{D(t,e)})),this.archetypeManager.resetArchetype(e),B(this.entities,e),this}getChangedFromComponents(...e){const t=this.componentManager.getInstances(e).filter(Boolean);if(t.length!==e.length)throw new Error("Not all components registered!");const n=Object.values(t).map((e=>e.changed)),r=new Set;return()=>{r.clear();for(const e of n)for(const t of e)r.add(t);return r.values()}}getChangedFromQuery(e){const{components:t}=this.queryManager.getQueryInstance(e),n=Object.values(t).map((e=>e.changed)),r=new Set;return()=>{r.clear();for(const e of n)for(const t of e)r.add(t);return r.values()}}getComponentInstance(e){return this.componentManager.componentMap.get(e)}getComponentInstances(...e){return this.componentManager.getInstances(e)}getEntityProperties(e){const t=this.archetypeManager.getArchetype(e);if(!t)return{};const{components:n}=t;return Object.fromEntries(n.map((t=>{const{name:n,schema:r}=t;let i=!0;return r&&(i=Object.fromEntries(Object.keys(r).map((n=>[n,t[n]?.[e]])))),[n,i]})))}getQueryComponents(e){return this.queryManager.getComponentsFromQuery(e)}getQueryEntered(e){return this.queryManager.getEnteredFromQuery(e)}getQueryEntities(e){return this.queryManager.getEntitiesFromQuery(e)}getQueryExited(e){return this.queryManager.getExitedFromQuery(e)}hasComponent(e){const t=this.componentManager.getInstance(e);if(!t)throw new Error("Component is not registered.");return e=>C(t[i],e)}hasComponents(...e){const t=this.componentManager.getInstances(e).filter(Boolean);if(t.length!==e.length)throw new Error("Not all components registered!");return e=>t.map((t=>C(t[i],e)))}isEntityActive(e){return this.isValidEntity(e)?C(this.entities.field,e):null}isValidEntity(e){return s(e)&&e<w(this.entities.field)}load(e){const{buffer:t,capacity:n,version:r}=e;if(r!==this.version)throw new Error(`Version mismatch. Trying to load ${r} data into ${this.version} world.`);if(n!==this.capacity)throw new Error(`Capacity mismatch. Data requires a world with a capacity of ${n}.`);return this.componentManager.setBuffer(t),this.refresh(),this}refresh(){return this.queryManager.refreshQueries(),this.archetypeManager.refreshArchetypes(this.queryManager.queryMap),this.componentManager.refreshComponents(),this}removeComponentsFromEntity(...e){const t=this.componentManager.removeComponentsFromEntity(e);return e=>{if(!this.isValidEntity(e))throw new SyntaxError(`Entity ${e} is not valid!`);return this.archetypeManager.updateArchetype(e,t(e)),this}}save(){return Object.freeze({buffer:this.componentManager.getBuffer(),capacity:this.capacity,version:this.version})}}export{f as Component,d as Query,m as System,Y as World};
//# sourceMappingURL=miski.min.js.map
